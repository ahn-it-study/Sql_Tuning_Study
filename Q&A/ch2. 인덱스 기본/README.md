
## Q&A

### 1. 대량의 데이터를 읽는다. 
- 테이블의 100만건 버퍼풀에 올리게 되면 데이터 스왑때문에 인덱스를 사용하면 더 비효율적이지않나?

### 2. B+ tree depth 관련 내용.
- B+ tree의 depth는 root - branch - leaf 구조이지만 leaf가 깊이가 더 깊어 질 수도 있다. 
  - 핵심은 모든 leaf 노드의 트리 깊이는 항상 같다는 것이다.

### 3. 수평적 탐색의 예시
- 수평적 탐색의 이유는 Leaf에서 VALUE가 동일할 경우 Last Value를 찾을 수 있다.

### 4. 결합 인덱스
- 선택도가 낮은 컬럼을 앞으로 두고 결합 인덱스를 생성해야 성능에 유리
  - 그러한 경우도 있지만 반드시 선택도가 낮은 컬럼을 앞에 두는 것이 성능에 유리하다고 설명하면 안된다.   
    인덱스의 구조는 B+tree방식을 취하기 때문에 컬럼의 상관없이 일량은 동일하기 때문이다. 성능에 영향을 주는 것은 맞다.

### 5. 결합 인덱스에 B+tree 구성 방식은?
- 결합 인덱스 모두 B+tree를 구성하는데 영향을 미친다.

### 6. ORDER BY에서 ||는 OR를 의미하는가 CONCAT을 의미하는가?
- ORDER BY 변경일자 || 변경순번 -> CONCAT 방식

### 7. 자동형변환 
- RDBMS마다 자동형변환을 지원하는 방식이 다르다.
  - 성능을 목적으로 자동형변환을 생략하는 것은 옳지 않다.

### 8. Index Skip Scan
- 결국 수직적 탐색 logn + 수평적 탐색 n은 맞다.    
  하지만 수평적 탐색을 할 때 해당 블록을 액세스 할지말지 결정한다는 장점이 있다.    
  반드시는 아니지만 Index Full Scan > Index Skip Scan > Index Range Scan 단위로 액세스 범위가 줄어든다고 생각하면 좋다.

### 9. Index Fast Full Scan 
- 디스크에 있는 대량의 데이터를 버퍼 블록에 담아오기 때문에 기존 캐시를 다 날려버릴수 있는 이슈가 존재한다.


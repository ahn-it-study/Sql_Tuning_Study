
## Q&A

### 1. 조건절에 매치되는 데이터가 많은 경우 TABLE FULL SCAN보다 INDEX FULL SCAN이 더 효율적이라는 질문
- 근거: TABLE이 몇 GB되는 경우 캐시, 다른 txn이 보고있던 스냅샷, 메타데이터 등 참조되고있던 것들이 스왑아웃으로 희생될수도 있는 
        가능성이 존재하기 때문에 INDEX FULL SCAN을 통해서 그나마 최소한의 블록을 액세하는 것이 좋지않을까?
  - SQL 튜닝의 가장 중요한 것중 하나가 RANDOM I/O를 줄이는 것이고 대량의 INDEX SCAN(다수의 RANDOM I/O) + 대량의 TABLE ACCESS가 발생하면 더 비효율적일 수도 있다.

- 캐시, 스냅샷, 메타데이터 관련 스왑아웃 가능성은 어떻게 해결할 것인가??
  - 추후 보완
- columnar db였다면 테이블 전체 안올리고 해당 column 만 올릴수도있을테니 걔는 또 다른 가능성을 가지고 있지 않을까?...
  - 추후 보완

### 2. B+ tree depth 관련 내용.
- B+ tree의 depth는 root - branch - leaf 구조이지만 leaf가 깊이가 더 깊어 질 수도 있다. 
  - 핵심은 모든 leaf 노드의 트리 깊이는 항상 같다는 것이다.

### 3. 수평적 탐색의 예시
- 수평적 탐색의 이유는 Leaf에서 VALUE가 동일할 경우 Last Value를 찾을 수 있다.

### 4. 결합 인덱스
- 선택도가 낮은 컬럼을 앞으로 두고 결합 인덱스를 생성해야 성능에 유리
  - 그러한 경우도 있지만 반드시 선택도가 낮은 컬럼을 앞에 두는 것이 성능에 유리하다고 설명하면 안된다.   
    인덱스의 구조는 B+tree방식을 취하기 때문에 컬럼의 상관없이 일량은 동일하기 때문이다. 성능에 영향을 주는 것은 맞다.

### 5. 결합 인덱스에 B+tree 구성 방식은?
- 결합 인덱스 모두 B+tree를 구성하는데 영향을 미친다.

### 6. ORDER BY에서 ||는 OR를 의미하는가 CONCAT을 의미하는가?
- ORDER BY 변경일자 || 변경순번 -> CONCAT 방식

### 7. 자동형변환 
- RDBMS마다 자동형변환을 지원하는 방식이 다르다.
  - 성능을 목적으로 자동형변환을 생략하는 것은 옳지 않다.

### 8. Index Skip Scan
- 결국 수직적 탐색 logn + 수평적 탐색 n은 맞다.    
  하지만 수평적 탐색을 할 때 해당 블록을 액세스 할지말지 결정한다는 것이 관건이다.    
  반드시는 아니지만 Index Full Scan > Index Skip Scan > Index Range Scan 단위로 액세스 범위가 줄어든다고 생각하면 좋다.

### 9. Index Fast Full Scan 
- 디스크에 있는 대량의 데이터를 버퍼 블록에 담아오기 때문에 기존 캐시를 다 날려버릴수 있는 이슈가 존재한다.


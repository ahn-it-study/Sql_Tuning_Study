# 소트 연산에 대한 이해
- SQL 수행 도중 가공된 데이터 집합이 필요할 때 오라클은 PGA와 Temp 테이블 스페이스를 이용함.
- 소트 머지 조인, 해시 조인, 데이터 소트와 그룹핑 등이 대표적
## 소트 수행 과정
- 소트는 PGA에 할당한 Sort Area에서 이루어진다.
- 메모리 공간인 Sort Area가 다 차면 디스크 Temp 테이블 스페이스를 활용한다.
- Sort Area에서 작업을 완료 할 수 있는지에 따라 아래와 같은 두가지 유형으로 나눈다.
1. In Memory Sort: 정렬 작업을 메모리 (PGA에 할당한 Sort Area)내에서 완료하는 것
2. Disk Sort: 할당받은 Sort Area 내에서 정렬을 완료하지 못해 디스크 공간(Temp 테이블 스페이스) 까지 사용하는 경우를 말함.
![무제](https://user-images.githubusercontent.com/23313008/167917243-f9f60bc0-6d7b-4848-8b87-6281dd2e6e44.png)  
소트 연산은 메모리 잡약적일 뿐만 아니라 CPU 집약적이기도 하다.  
처리할 데이터량이 많을 때는 디스크 I/O까지 발생하므로 쿼리 성능을 좌우하는 매우 중요한 요소이다.  
하지만 디스크 소트(Temp 테이블 스페이스)가 발생하는 순간 성능을 나빠질 수 밖에 없다.(위 그림에서 보시다시피..)  
디스크 I/O가 발생하는것도 문제지만 부분범위 처리를 불가능하게 함으로써 OLTP 환경에서 애플리케이션 성능을 저하시키는 주요인이 되기도 한다.  
- 될 수 있으면 소트가 발생하지 않도록 SQL 작성을 하고 소트가 불가피하다면 메모리 내에서 수행을 완료 할 수있게 해라.  
## Sort Operation
### Sort Aggregate
- 전체 로우를 대상으로 집계를 수행할 때 나타낸다. Sort라는 의미를 사용하지만 실제로 데이터를 정렬하지는 않는다.
- Sort Area를 사용한다는 의미로 이해하면 된다.
- 데이터를 정렬하지 않고 SUM, MAX, MIN, AVG 값 구하는 절차를 설명하면 아래와 같다.
1. Sort Area에 SUM, MAX, MIN, COUNT 값을 위한 변수를 하나씩 할당한다.
2. EMP 테이블 첫 번째 레코드에서 읽은 SAL 값을 SUM, MAX, MIN 변수에 저장하고 COUNT 변수에는 1을 저장한다.
3. EMP 테이블에서 레코드를 하나씩 읽어 내려가면서 sum 변수에는 값을 누적하고 MAX변수에는 기존보다 큰 값이 나타날 때 마다 값을 대체하고
3. MIN변수에는 기존보다 작은 값이 나타날 때마다 값을 대체한다. COUNT 변수에는 SAL값이 NULL이 아닌 레코드를 만날 때 마다 1씩 증가시킨다.
4. EMP 레코드를 다 읽고 나면 아래 그림처럼 값이 저장되어있다 SUM,MAX, MIN값은 변수에 담긴 값을 그대로 출력하고 AVG는 sum 값을 COUNT 값으로 나눈 2800을 출력하면 된다.
![무제](https://user-images.githubusercontent.com/23313008/168136994-22641886-70ae-4953-8d0c-623cb7636b28.png)  
### Sort Order By
- 데이터를 정렬할 때 나타낸다.
### Sort Group By
- 소팅 알고리즘을 사용해 그룹별 집계를 수행할 때 나타낸다.
> 수천명의 사원(EMP)이 근무하는 회사를 가정해보자. 부서는 네 개뿐이며 부서코드로는 각각 10,20,30,40을 사용한다.
부서별 급여(SAL)을 집계하려고 할 때 어떤 방법을 사용하면 좋을까?  
![무제](https://user-images.githubusercontent.com/23313008/168138008-8e5a96c0-324b-4579-b56a-ff535d490f3f.png)  
위 그림처럼 10부터 40까지 적은 메모지 네 개만 준비하면 된다.  
각 메모지에 SUM, MAX, MIN, COUNT를 적을 수 있도록 입력란을 두고 메모지를 부서번호 순으로 정렬해 놓으면 준비 끝이다.  
이제 급여 정보를 읽기 시작한다. 읽은 각 사원의 부서번호에 해당하는 메모지를 찾는다.  
정렬돼 있으므로 메모지 찾기는 어렵지 않다. 메모지를 찾았으면 sum, max, min, count 값을 갱신한다.
Sort Aggregate에서 사용했던 방식을 여기서도 똑같이 사용한다.  
급여 대장을 다 읽고 나서 메모지에 기록돼있는 정보가 우리가 원하던 부서별 급여 집계다.  
부서 개수를 미리 알 수 없다면 급여 대장을 읽다가 새로운 부서가 나타날 때 마다 새로 준비한 메모지를 정렬 순서에 맞춰 중간에 끼워넣어주면 된다.  
이 방식을 사용한다면 사원이 수억 명이어도 단 네장의 메모지만 있으면 된다는 사실에 주목하자.  
부서가 많지 않다면 Sort Area가 클 필요가 전혀 없다. 집계할 대상 레코드가 아무리 많아도 Temp 테이블 스페이스를 쓰지 않는다는 뜻이다.  
### Sort Unique
- 옵티마이저가 서브쿼리를 풀어 일반 조인문으로 변환하는 것을 서브쿼리 Unnesting 이라고 한다.  
- Unnesting된 서브쿼리가 M쪽 집합이면 메인 쿼리와 조인하기 전에 중복 레코드부터 제거해야한다.
- 만약 PK/Unique 제약 또는 Unique 인덱스를 통해 Unnesting된 서브쿼리의 유일성이 보장된다면 Sort Unique 오퍼레이션은 생략된다.
- Union, Minus, Intersect 같은 집합 연산자를 사용할 때도 아래와 같이 Sort Unique 오퍼레이션이 나타난다.
- Distinct 연산자를 사용해도 Sort Unique 오퍼레이션이 나타난다.
### Sort Join
- Sort Join 오퍼레이션은 소트 머지 조인을 수행할 때 나타난다.
### Window Sort
- Window Sort는 윈도우 함수(분석함수)를 수행할 때 나타난다.
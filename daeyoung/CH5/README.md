# 소트 연산에 대한 이해
- SQL 수행 도중 가공된 데이터 집합이 필요할 때 오라클은 PGA와 Temp 테이블 스페이스를 이용함.
- 소트 머지 조인, 해시 조인, 데이터 소트와 그룹핑 등이 대표적
## 소트 수행 과정
- 소트는 PGA에 할당한 Sort Area에서 이루어진다.
- 메모리 공간인 Sort Area가 다 차면 디스크 Temp 테이블 스페이스를 활용한다.
- Sort Area에서 작업을 완료 할 수 있는지에 따라 아래와 같은 두가지 유형으로 나눈다.
1. In Memory Sort: 정렬 작업을 메모리 (PGA에 할당한 Sort Area)내에서 완료하는 것
2. Disk Sort: 할당받은 Sort Area 내에서 정렬을 완료하지 못해 디스크 공간(Temp 테이블 스페이스) 까지 사용하는 경우를 말함.
![무제](https://user-images.githubusercontent.com/23313008/167917243-f9f60bc0-6d7b-4848-8b87-6281dd2e6e44.png)  
소트 연산은 메모리 잡약적일 뿐만 아니라 CPU 집약적이기도 하다.  
처리할 데이터량이 많을 때는 디스크 I/O까지 발생하므로 쿼리 성능을 좌우하는 매우 중요한 요소이다.  
하지만 디스크 소트(Temp 테이블 스페이스)가 발생하는 순간 성능을 나빠질 수 밖에 없다.(위 그림에서 보시다시피..)  
디스크 I/O가 발생하는것도 문제지만 부분범위 처리를 불가능하게 함으로써 OLTP 환경에서 애플리케이션 성능을 저하시키는 주요인이 되기도 한다.  
- 될 수 있으면 소트가 발생하지 않도록 SQL 작성을 하고 소트가 불가피하다면 메모리 내에서 수행을 완료 할 수있게 해라.  
## Sort Operation
### Sort Aggregate
- 전체 로우를 대상으로 집계를 수행할 때 나타낸다. Sort라는 의미를 사용하지만 실제로 데이터를 정렬하지는 않는다.
- Sort Area를 사용한다는 의미로 이해하면 된다.
- 데이터를 정렬하지 않고 SUM, MAX, MIN, AVG 값 구하는 절차를 설명하면 아래와 같다.
1. Sort Area에 SUM, MAX, MIN, COUNT 값을 위한 변수를 하나씩 할당한다.
2. EMP 테이블 첫 번째 레코드에서 읽은 SAL 값을 SUM, MAX, MIN 변수에 저장하고 COUNT 변수에는 1을 저장한다.
3. EMP 테이블에서 레코드를 하나씩 읽어 내려가면서 sum 변수에는 값을 누적하고 MAX변수에는 기존보다 큰 값이 나타날 때 마다 값을 대체하고
3. MIN변수에는 기존보다 작은 값이 나타날 때마다 값을 대체한다. COUNT 변수에는 SAL값이 NULL이 아닌 레코드를 만날 때 마다 1씩 증가시킨다.
4. EMP 레코드를 다 읽고 나면 아래 그림처럼 값이 저장되어있다 SUM,MAX, MIN값은 변수에 담긴 값을 그대로 출력하고 AVG는 sum 값을 COUNT 값으로 나눈 2800을 출력하면 된다.
![무제](https://user-images.githubusercontent.com/23313008/168136994-22641886-70ae-4953-8d0c-623cb7636b28.png)  
### Sort Order By
- 데이터를 정렬할 때 나타낸다.
### Sort Group By
- 소팅 알고리즘을 사용해 그룹별 집계를 수행할 때 나타낸다.
> 수천명의 사원(EMP)이 근무하는 회사를 가정해보자. 부서는 네 개뿐이며 부서코드로는 각각 10,20,30,40을 사용한다.
부서별 급여(SAL)을 집계하려고 할 때 어떤 방법을 사용하면 좋을까?  
![무제](https://user-images.githubusercontent.com/23313008/168138008-8e5a96c0-324b-4579-b56a-ff535d490f3f.png)  
위 그림처럼 10부터 40까지 적은 메모지 네 개만 준비하면 된다.  
각 메모지에 SUM, MAX, MIN, COUNT를 적을 수 있도록 입력란을 두고 메모지를 부서번호 순으로 정렬해 놓으면 준비 끝이다.  
이제 급여 정보를 읽기 시작한다. 읽은 각 사원의 부서번호에 해당하는 메모지를 찾는다.  
정렬돼 있으므로 메모지 찾기는 어렵지 않다. 메모지를 찾았으면 sum, max, min, count 값을 갱신한다.
Sort Aggregate에서 사용했던 방식을 여기서도 똑같이 사용한다.  
급여 대장을 다 읽고 나서 메모지에 기록돼있는 정보가 우리가 원하던 부서별 급여 집계다.  
부서 개수를 미리 알 수 없다면 급여 대장을 읽다가 새로운 부서가 나타날 때 마다 새로 준비한 메모지를 정렬 순서에 맞춰 중간에 끼워넣어주면 된다.  
이 방식을 사용한다면 사원이 수억 명이어도 단 네장의 메모지만 있으면 된다는 사실에 주목하자.  
부서가 많지 않다면 Sort Area가 클 필요가 전혀 없다. 집계할 대상 레코드가 아무리 많아도 Temp 테이블 스페이스를 쓰지 않는다는 뜻이다.  
### Sort Unique
- 옵티마이저가 서브쿼리를 풀어 일반 조인문으로 변환하는 것을 서브쿼리 Unnesting 이라고 한다.  
- Unnesting된 서브쿼리가 M쪽 집합이면 메인 쿼리와 조인하기 전에 중복 레코드부터 제거해야한다.
- 만약 PK/Unique 제약 또는 Unique 인덱스를 통해 Unnesting된 서브쿼리의 유일성이 보장된다면 Sort Unique 오퍼레이션은 생략된다.
- Union, Minus, Intersect 같은 집합 연산자를 사용할 때도 아래와 같이 Sort Unique 오퍼레이션이 나타난다.
- Distinct 연산자를 사용해도 Sort Unique 오퍼레이션이 나타난다.
### Sort Join
- Sort Join 오퍼레이션은 소트 머지 조인을 수행할 때 나타난다.
### Window Sort
- Window Sort는 윈도우 함수(분석함수)를 수행할 때 나타난다.
## 소트가 발생하지 않도록 SQL 작성
SQL 작성할 떄 불필요한 소트가 발생하지 않도록 주의해야 한다.  
Union, Minus, Distinct 연산자는 중복 레코드를 제거하기 위한 소트 연산을 발생시키므로 꼭 필요한 경우에만 사용하고  
성능이 느리다면 소트 연산을 피할 방법이 있는지 찾아봐야 한다.  
### Union VS Union All
SQL에 Union을 사용하면 옵티마이저는 상단과 하단 두 집합 간 중복을 제거하려고 소트 작업을 수행한다.  
반면 Union All 은 중복을 확인하지 않고 두 집합을 단순히 결합하므로 소트 작업을 수행하지 않는다.  
따라서 될 수 있으면 Union All을 사용해야 한다.  
Union을 Union All로 변경하려다 자칫 결과 집합이 달라질 수 있으므로 주의해야한다.  
```sql
SELECT 결제번호, 주문번호, 결제금액, 주문일자
FROM 결졔
WHERE 결제수단코드 = 'M' and 결제일자 = '20180316'
UNION 
SELECT 결제번호, 주문번호, 결제금액, 주문일자
FROM 결졔
WHERE 결제수단코드 = 'C' and 결제일자 = '20180316'
```
위 SQL은 상단과 하단 집합의 인스턴스 중복 가능성이 없다.  
결제수단코드 조건절에 다른 값을 입력했기 떄문이다.  
그런데도 Union을 사용함으로 인해 소트 연산을 발생시키고 있다.  
위 아래 두 집합이 상호배타적이므로 Union 대신 Union All을 사용해도 된다.  
```sql
SELECT 결제번호, 주문번호, 결제금액, 주문일자
FROM 결졔
WHERE 결제일자 = '20180316'
UNION 
SELECT 결제번호, 주문번호, 결제금액, 주문일자
FROM 결졔
WHERE 주문일자 = '20180316'
```
위 SQL은 Union 상단과 하단 집합 사이에 인스턴스 중복 가능성이 있다.  
결제와 주문일자 조건은 상호배타적 조건이 아니기 때문이다.  
만약 Union을 Union All로 변경하면 결제일자와 주문일자가 같은 결제 데이터가 중복해서 출력된다.  
소트연산이 일어나지 않도록 Union All을 사용하면서도 데이터 중복을 피하려면 아래와 같이 하면 된다.  
```sql
SELECT 결제번호, 주문번호, 결제금액, 주문일자
FROM 결졔
WHERE 결제수단코드 = 'M' and 결제일자 = '20180316'
UNION 
SELECT 결제번호, 주문번호, 결제금액, 주문일자
FROM 결졔
WHERE 결제수단코드 = 'C' and 결제일자 = '20180316'
and 결제일자 <> '20180316'
```
참고로 결제일자가 Null 허용 컬럼이면 맨 아래 조건절을 아래와 같이 변경해야한다. 
```sql
and (결제일자 <> '20180316' or 결제일자 is null)
```
### Exists 활용
중복 레코드를 제거할 목적으로 Distinct 연산자를 종종 사용해야하는데, 이 연산자를 사용하면 조건에 해당하는 데이터를 모두 읽어서  
중복을 제거해야한다.  
부분범위처리는 불가능하고 모든 데이터를 읽는 과정에 많은 I/O가 발생한다.  
예를들어 상품과 계약 테이블이 있다 계약_X2 인덱스 구성이 [상품번호 + 계약일자]일 때 아래 쿼리는 상품유형코드 조건절에  
해당하는 상품에 대해 계약일자 조건 기간에 발생한 계약 데이터를 모두 읽는 비효율이 있다.  
```sql
SELECT DISTINCT p.상품번호, p.상품명, p.상품가격
FROM 상품 p, 계약 c
WHERE p.상품유형코드 = :pclscd
and c.상품번호 = p.상품번호
and c.계약일자 between :dt1 and :dt2
and c.게약구분코드 = :ctpcd
```
쿼리를 다음과 같이 바꿔보자  
```sql
SELECT DISTINCT p.상품번호, p.상품명, p.상품가격
FROM 상품 p
WHERE p.상품유형코드 = :pclscd
and EXISTS ( SELECT 'x' from 계약 c
WHERE c.상품번호 = p.상품번호
and c.계약일자 between :dt1 and :dt2
and c.게약구분코드 = :ctpcd)
```
EXISTS 서브 쿼리는 데이터 존재 여부만 확인하면 되기 때문에 조건절을 만족하는 데이터를 모두 읽지 않는다.  
위 쿼리로 말하면 상품유형코드 조건절 p.상품유형코드 = :pclscd에 해당하는 상품에 대해 계약일자 조건 기간에 발생한 계약 중 계약구분 코드 조건절을  
만족하는 데이터가 한건이라도 존재하는지만 확인한다.  
DISTINCT 연산자를 사용하지 않았으므로 상품 테이블에 대한 부분범위 처리도 가능하다.  
DISTINCT, MINUS 연산자를 사용한 쿼리는 대부분 Exists 서브 쿼리로 변환이 가능하다.
### 조인방식변경
조인문 일 때는 조인 방식도 잘 선택해줘야한다.  
아래 SQL 문에서 계약_X01 인덱스가 지점ID + 계약일시 순이면 소트 연산을 생략할 수 있지만  
해시 조인이기 떄문에 Sort Order By가 나타났다.  
```sql
SELECT p.상품번호, p.상품명, c.계약번호, c.상품코드, c.계약일시, c.계약금액
FROM 상품 p, 계약 c
WHERE c.지점ID = :brch_id
AND p.상품코드 = c.상품코드
ORDER BY c.계약일시 desc
```
아래와 같이 계약 테이블 기준으로 상품 테이블과 NL 조인하도록 조인 방식을 변경하면 소트 연산을 생략할 수 있어  
지점ID 조건을 만족하는 데이터가 많고 부분범위 처리 가능한 상황에서 큰 성능 개선 효과를 얻을 수 있다.  
```sql
SELECT /*+ leading(c) use_nl(p) */ p.상품번호, p.상품명, c.계약번호, c.상품코드, c.계약일시, c.계약금액
FROM 상품 p, 계약 c
WHERE c.지점ID = :brch_id
AND p.상품코드 = c.상품코드
ORDER BY c.계약일시 desc
```
정렬 기준이 조인 키 컬럼이면 소트 머지 조인도 Sort Order By 연산을 생략할 수있다.  
## 인덱스를 이용한 소트 연산 생략
인덱스 선두 컬럼을 종목코드 + 거래일시 순으로 구성하지 않으면 아래 쿼리에서 소트연산을 생략할 수 없다.  
```sql
SELECT 거래일시, 체결건수, 체결수량, 거래대금
FROM 종목거래
WHERE 종목코드 = 'KR123456'
ORDER BY 거래일시
```
종목코드 = 'KR123456' 조건을 만족하는 레코드를 인덱스에서 모두 읽어야 하고 그만큼 많은 테이블 랜덤 액세스가 발생한다.  
모든 데이터를 다 읽어 거래일시 순으로 정렬을 마치고서야 출력을 시작하므로 OLTP 환경에서 요구되는 빠른 응답속도를 내기 어렵다.  
## Top N 쿼리
Top N 쿼리는 전체 결과집합 중 상위 N개 레코드만 선택하는 쿼리다.  
SQL Server 나 Sybase는 Top N 쿼리를 손쉽게 작성할 수 있다.  
### 페이징 처리
3 tier 환경에서 부분범위 처리를 어떻게 응용할지 아이디어가 생겼는가?  
답은 페이징처리에 있다.  
3-Tier 환경에서는 대량의 결과집합을 조회할 때 페이징 처리 기법을 활용한다.  
일반적으로 표준 패턴은 아래와 같다
```sql
SELECT * 
FROM (
    SELECT rownum no, a.*
    FROM (
        /* SQL Body */
    ) a
    WHERE rownum <= (:page * 10)
)
WHERE no >= (:page - 1) * 10 + 1
```
Top N 쿼리이므로 ROWNUM으로 지정한 건수만큼 결과 레코드를 얻으면 거기서 바로 멈춘다.  
뒤쪽 페이지로 이동할수록 읽는 데이터량도 많아지는 단점이 있지만, 보통 앞쪽 일부 데이터만 확인하므로 문제가 되지 않는다.  
예를 들어 인터넷 카페 게시글 목록을 조회하거나 은행 사이트에서 입출금 내역을 조회할 때 일반적으로 1~2 페이지만 확인한다.  
3-Tier 환경에서 부분범위 처리를 활용하기 위해 우리가 할 일은 다음과 같다.  
1. 부분범위 처리 가능하도록 SQL을 작성한다. 부분범위 처리가 잘 작동하는지 토드, 오렌지 같은 툴에서 테스트한다.
2. 작성한 SQL 문을 페이징 처리용 표준 패턴 SQL Body 부분에 붙여넣는다.
부분범위 처리 가능하도록 SQL을 작성한다는 의미는 무엇일까?  
인덱스 사용 가능하도록 조건절을 구사하고 조인은 NL 조인 위주로 처리하고, Order By 절이 있어도 소트 연산을 생략할 수 있도록 인덱스를 구성해주는 것을 말한다.  
### 최소값/최대값 구하기
MIN, MAX를 구하는 SQL 실행계획을 보면 Sort Aggregate 오퍼레이션이 나타난다.  
Sort Aggregate를 위해 전체 데이터를 정렬하진 않지만 전체 데이터를 읽으면서 값을 비교한다고 앞에서 설명하였다.  
인덱스는 정렬돼 있으므로 이를 이용하면 전체 데이터를 읽지 않고도 최소 또는 최대값을 쉽게 찾을 수 있다.  
인덱스 맨 왼쪽으로 내려가서 첫 번째 읽는 값이 최소값이고 맨 오른쪽으로 내려가서 첫 번째 읽는 값이 최대값이다.  
### 인덱스를 이용해 최소/최대값 구하기 위한 조건
전체 데이터를 읽지 않고 인덱스를 이용해 최소 또는 최대값을 구하려면 조건절 컬럼과 MIN/MAX 함수 인자 컬럼이 모두  
인덱스에 포함돼 있어야 한다.  
즉 테이블 액세스가 발생하지 않아야 한다.  
```sql
CREATE INDEX EMP_X1 ON EMP(DEPTNO, MGR, SAL);
SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30 AND MGR = 7698;
```
위 쿼리는 인덱스를 DEPTNO + MGR + SAL 순으로 구성한 경우이다.
조건절 컬럼과 MAX 컬럼이 모두 인덱스에 포함돼 있고 인덱스 선두 컬럼 DEPTNO, MGR이 모두 등치 조건이므로  
가장 오른쪽에 있는 값 하나를 읽는다.  
실행계획을 보면 FIRST ROW라는것을 볼 수 있게되는데 이는 조건을 만족하는 레코드 하나를 찾았을 때 멈추는것을 의미한다.  
지금부터 이를 First Row Stopkey 알고리즘이라고 부르자.  
```sql
CREATE INDEX EMP_X1 ON EMP(DEPTNO, SAL, MGR);
SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30 AND MGR = 7698;
```
위는 인덱스 DEPTNO + SAL + MGR 순으로 구성한 경우이다.  
DEPTNO = 30 조건을 만족하는 MAX(SAL) 값을 쉽게 찾을 수 있는 구성이다.  
DEPTNO = 30 조건을 만족하는 범위 가장 오른쪽으로 내려가면 가장 큰 SAL 값을 만나게 된다.  
거기서 부터 시작해 MGR = 7698 조건을 만족하는 레코드 하나를 찾았을 때 멈추면된다.  
즉 DEPTNO는 액세스 조건 MGR은 필터조건이다.  
여기서도 조건절 컬럼과 MAX 컬럼이 모두 인덱스에 포함되어 있으므로 First Row Stopkey 알고리즘이 작동한다.  
```sql
CREATE INDEX EMP_X1 ON EMP(SAL, DEPTNO, MGR);
SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30 AND MGR = 7698;
```
위 쿼리는 인덱스를 SAL + DEPTNO + MGR로 구성한 경우다.  
조건절 컬럼이 둘 다 인덱스 선두 컬럼이 아니므로 Index Range Scan은 불가능하다.  
Index Full Scan 방식으로 인덱스 전체 레코드 중 가장 오른쪽에서 스캔을 시작해 DEPTNO = 30 조건과 MGR = 7698 조건을  
만족하는 레코드 중 가장 오른쪽에서 스캔을 시작해 DEPTNO = 30 조건과 MGR = 7698 조건을 만족하는  
레코드 하나를 찾았을 때 멈추면 된다. DEPTNO MGR 모두 필터조건이다.  
여기서도 조건절과 MAX 컬럼이 모두 인덱스에 포함돼 있으므로 First Row Stopkey 알고리즘이 작동한다.  
```sql
CREATE INDEX EMP_X1 ON EMP(DEPTNO, SAL);
SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30 AND MGR = 7698;
```
위 쿼리는 조건절 컬럼과 MAX 컬럼중 어느 하나가 인덱스에 포함돼 있지 않은 경우이다.  
인덱스를 DEPTNO + SAL 로 구성했으므로 DEPTNO = 30 조건을 만족하는 MAX(SAL) 은 쉽게 찾을 수 있다.  
그런데 MGR 컬럼이 인덱스에 없으므로 MGR = 7698 조건은 테이블에서 필터링 해야만한다.  
이 경우 First Row Stopkey 알고리즘이 작동하지 않는다.  
### Top N 쿼리를 이용해 최소/최대값 구하기
Top N 쿼리를 통해서도 최소 또는 최대값을 쉽게 구할 수 있다.  
아래와 같이 ROWNUM <= 조건을 이용해 Top 1 레코드를 찾으면 된다.  
```sql
CREATE INDEX EMP_X1 ON EMP(DEPTNO, SAL);

SELECT * 
FROM (
    SELECT SAL
    FROM EMP
    WHERE DEPTNO = 30
    AND MGR = 7698
    ORDER BY SAL DESC
)
WHERE ROWNUM <= 1;
```
Top N 쿼리에 작동하는 Top N Stopkey 알고리즘은 모든 컬럼이 인덱스에 포함돼 있지 않아도 잘 작동한다.  
즉 위 SQL에서 MGR 컬럼이 인덱스에 없지만 가장 큰 SAL 값을 찾기 위해 DEPTNO = 30 조건을 만족하는 전체 레코드를 읽지 않는다.  
### 이력 조회
일반 테이블은 각 컬럼의 현재 값만 저장하므로 변경되기 이전 값을 알 수 없다.  
값이 어떻게 변경돼 왔는지 과거 이력을 조회할 필요가 있다면 이력 테이블을 따로 관리해야한다.  
과거 변경이력을 관리하기 위해 이력 테이블을 두지만 일반적으로 이 테이블에는 현재 데이터도 저장한다.  
그렇게 구현해야 변경 이력을 완벽히 재생할 수 있기 때문이다.  
예를들어 특정 장비의 최종 상태코드가 A2 인데 이 값으로 바뀐 날짜를 알고싶다면 이력테이블에서 확인해야 한다.  
장비 테이블에도 최종변경일자가 있지만 이 값을 이용할 순 없다.  
이 값은 상태코드 이외의 컬럼 즉 장비명 또는 장비구분코드가 바뀔 때도 갱신되기 때문이다.  
### Sort Group By 생략
인덱스를 이용해 소트 연산을 생략할 수 있다는 사실은 많이 알려졌고 이해하기도 비교적 쉽다.  
반면, 그룹핑 연산에도 인덱스를 활용할 수 있다는 사실은 모르는 분이 많다.  
아래 SQ에 region이 선두 컬럼인 인덱스를 이용하면 Sort Group By 연산을 생략할 수 있다.  
## Sort Area를 적게 사용하도록 SQL 작성
소트 연산이 불가피하다면 메모리 내에서 처리를 완료할 수 있도록 노력해야한다.  
Sort area 크기를 늘리는 방법도 있지만 그전에 Sort Area를 적게 사용할 방법부터 찾는것이 순서다.  
### 소트 데이터 줄이기
특정 기간에 발생한 주문상품 목록을 파일로 내리고자 한다. 아래 두 SQL중 어느쪽이 Sort Area를 더 적게 사용할까?  
```sql
// 1번
SELECT lpad(상품번호, 30) || lpad(상품명, 30) || lpad(고객ID, 10) || lpad(고객명, 20) || to_char(주문일시, 'yyyymmdd hh24:mi:ss')
FROM 주문상품
WHERE 주문일시 between :start and :end
ORDER BY 상품번호
```
```sql
// 2번
SELECT lpad(상품번호, 30) || lpad(상품명, 30) || lpad(고객ID, 10) || lpad(고객명, 20) || to_char(주문일시, 'yyyymmdd hh24:mi:ss')
FROM (
    SELECT 상품번호, 상품명, 고객ID, 고객명, 주문일시
    FROM 주문상품
    WHERE 주문일시 between :start and :end
    ORDER BY 상품번호
)
```
1번 SQL은 레코드당 107바이트로 가공한 결과 집합을 Sort Area에 담는다. 반면 2번 SQL은 가공하지 않은 상태로 정렬을  
완료하고 나서 최종 출력할 때 가공한다.  
따라서 2번 SQL이 Sort Area를 훨씬 적게 사용한다.  
```sql
// 1번
SELECT * FROM 예수금원장 ORDER BY 총예수금 desc
```
```sql
// 2번
SELECT 계좌번호, 총예수금
FROM 예수금원장
ORDER BY 총예수금 desc
```
당연히 2번 SQL이 적게 사용한다.  
1번 SQL은 모둔 컬럼을 Sort Area에 저장하는 반면 2번 SQL은 계좌번호와 총예수금만 저장하기 때문이다.  
### Top N 쿼리의 소트 부하 경감 원리
전교생 1000명 중 가장 큰 학생 열 명을 선발하려고 한다. 다른 학교와 농구시합을 앞두고 있어서다.  
만약 전교생을 키 순서대로 정렬한 학생명부가 있다면 가장 위쪽에 있는 열 명을 선발하면 된다.  
이것이 Top N Stopkey 알고리즘이다. 그런 학생명부를 미리 준비해 두지 않았다면 아래와 같은 방법이 가장 효과적이지 않을까 싶다.  
1. 전교생을 운동장에 집합시킨다.
2. 맨 앞줄 맨 왼쪽에 있는 학생 열 명을 단상 앞으로 불러 키 순서대로 세운다.
3. 나머지 990명을 한명씩 교실로 들여보내면서 현재 Top 10위치에 있는 학생과 키를 비교한다. 더 큰 학생이 나타나면 현재 Top 10 위치에 있는 학생을 교실로 들여보낸다.
4. Top 10에 새로 진입한 학생 키에 맞춰 자리를 재배치한다.  
전교생이 다 교실로 들어갈 때 까지 3번과 4번 과정을 반복하면 최종적으로 그 학교에서 가장 키 큰 학생 열명만 운동장에 남는다.  
지금까지 설명한 알고리즘은 Top N Sort 알고리즘이라고 부르자.  

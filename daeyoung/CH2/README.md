# CH.2 인덱스 기본
> 챕터2의 핵심내용은 수직적 탐색과 수평적 탐색
# 인덱스란
- 책에 있는 목차라고 생각하면 됩니다.
## 인덱스에 대한 현실세계 시나리오
어느 한 초등학교에서 홍길동이라는 학생을 '효율적으로' 찾으려고 한다.  
첫번째 방법으로는 1학년 1반부터 6학년 6반까지 다 돌면서 찾는 방법이 있겠고  
두번재 방법으로는 교무실에 찾아가 학생명부를 보면서 홍길동이 있는 반을 찾아서 가는 방법이 있다.  
  
첫번재 방법은 Table Full Scan이고 홍길동이라는 이름을 가진 학생의 수가 많을 경우 더 효율적이고  
두번째 방법은 Index Range Scan이며 홍길동이라는 이름을 가진 학생의 수가 적을 경우 더 효율적이다.  
![RealWorldExample2](https://user-images.githubusercontent.com/23313008/164471007-1819f39c-ce4d-4db7-a93b-730e3ba9c0d6.png)

만약 이름으로 학생을 찾는 '방문객'이 많다면 위 표처럼 이름순으로 정렬해놓는것이 편하다.  
이것이 인덱스고 학년-반 컬럼이 인덱스 ROWID에 해당한다.  
# 인덱스를 사용하는 이유
## 2가지의 검색방법
- 테이블 전체를 스캔한다 (풀스캔)
- 인덱스를 이용한다.
## 인덱스를 이용해야하는 경우
인덱스를 이용해야하는 경우 -> 소량의 데이터를 읽는 경우  
Index Range Scan을 통한 테이블 액세스는 랜덤 액세스와 Single Block I/O방식으로 스캔한다.  
그렇기때문에 대량의 데이터를 읽을 풀스캔 보다 불리할 수 밖에 없다.  
## 인덱스를 이용했을 때 불리해지는 경우
대량의 데이터를 읽는 경우 인덱스를 이용하는게 더 비효율적이다  
위에서 설명했듯 인덱스의 경우 Single Block I/O, 랜덤 액세스로 스캔을 한다.  
하지만 Table Full Scan의 경우 Multi Block I/O, 시퀀셜 액세스로 스캔을하기때문에  
대량의 데이터를 읽을 땐(또는 읽을 데이터가 일정량을 넘을 땐) Index Range Scan보다 Table Full Scan이 유리하다.  
# 인덱스 튜닝의 두가지 핵심요소
인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다.  
세부적인 인덱스 튜닝 방법으론 여러가지가 있겠지만 핵심은 크게 두가지로 나뉜다.  
- 인덱스 스캔 효율화 튜닝
- 랜덤 액세스 최소화 튜닝
### 인덱스 스캔 효율화 튜닝
![Untitled Diagram drawio](https://user-images.githubusercontent.com/23313008/164474074-958aff4f-4ace-4a8d-97eb-3585455fec37.png)  
학생명부에서 시력이 '1.0~1.5' 사이인 '홍길동' 학생을 찾는 경우 이름과 시력순으로 정렬해두었다면 위 표와같이 소량만 스캔하면 된다  
반면 시력과 이름순으로 정렬해두었으면 똑같이 두명을 찾는데도 다음과 같이 많은양을 소비한다.
![Untitled Diagram drawio-3](https://user-images.githubusercontent.com/23313008/164475092-8828213f-0aae-4858-bd2d-c806b3d9c566.png)  

### 랜덤 액세스 최소화 튜닝
인덱스 스캔후 테이블 레코드를 액세스 할 때 랜덤 I/O방식을 사용한다. 그래서 이를 튜닝 하는것이  
'랜덤 액세스 최소화' 튜닝이라고 한다.  
다시 '인덱스 스캔 효율화 튜닝'에서 들었던 예제를 생각해보자    
시력이 1.0~1.5인 홍길동 학생을 찾아야하는경우에 이름으로 정렬된 인덱스와 시력으로 정렬된 인덱스가 있다고 가정해보자  
그리고 시력이 1.0~1.5인 학생은 50명이고 홀길동 학생은 5명이다.    
그러면 어떤것을 선택해야할까?  
정답은 이름으로 정렬된 인덱스를 선택해야한다.    
시력 인덱스를 선택해서 검색을 한다고 가정해보면 50번의 교실을 찾아가야한다.  
반면에 이름으로 정렬된 인덱스를 선택하면 5번만 교실로 찾아가면 된다.  
즉 랜덤 액세스 튜닝의 핵심은 교실을 찾아가는 횟수를 줄이는것이다.  
-> 여기서 말하는 '교실로 찾아간다'는 인덱스 스캔 후 테이블 액세스를 뜻함.
   
인덱스 효율화 튜닝과 랜덤 액세스 최소화 튜닝은 둘다 중요하지만 더 중요한 하나를 고른다고 하면 랜덤 엑세스 튜닝이다.  
학생명부를 뒤지는(인덱스 스캔) 과정에도 비효율이 있을 수 있지만 인덱스에 없는 정보를 찾기위해 테이블에 접근하는것만 못하다.  
-> 책에서 설명하는 결론: 'SQL튜닝은 랜덤 I/O와의 전쟁이다.' (인덱스에만 국한되지 않음.) 
# 인덱스 구조
![bookindex](https://user-images.githubusercontent.com/23313008/164478224-24f3c6bd-d539-41b4-a5a2-2d71400c53c2.png)
![Youtubue](https://user-images.githubusercontent.com/23313008/164478531-17d0d97e-ad36-4c36-b650-af026e1cd18a.png)  
실생활에서 쓰이는 인덱스의 예제를 가져와봤다.  
만약 내가 트리를 공부하고싶은데 색인 페이지가 없다면 모든 페이지를 다 뒤져서 찾아야한다.  
또한 내가 듣고싶은 노래가 있는데 색인 정보가 없다면 10초씩 넘기면서 내가 듣고싶은 노래가 나올때까지 찾아야한다.  
하지만 색인이 있다면 200~230페이지를 펴서 보면된다 그리고 바로 시간을 클릭해서 노래를 들으면 된다.  
즉 인덱스를 이용한다면 범위 스캔(Range Scan)이 가능하다.  범위 스캔이 가능한 이유는 인덱스가 정렬되어있기 때문이다.  
그러면 인덱스의 구조는 어떻게 되어있을까?  
- 보통의 DBMS에서 인덱스는 b+tree 자료구조를 가지고있다 (Mysql InnoDB!)
- Root, Branch, Leaf 노드가 있다.  
- 루트와 브랜치블록에 있는 각 레코드는 하위 블록에 대한 주소값을 가지고 있다.
![btree](https://user-images.githubusercontent.com/23313008/164485061-4d3f79ef-5ca6-4d4d-8ace-a4e414ce6b4e.png)  
(출처) https://ssup2.github.io/theory_analysis/B_Tree_B+_Tree/  
위 그림에서 트리 꼭대기에 있는 노드는 '루트'이고 루트 밑에 있는 노드들은 '브랜치'이며 브랜치 아래에 있는 노드들은 '리프'이다.  
루트와 브랜치 블록에 있는 각 레코들은 하위 블록에 대한 주소값을 가지고 있다.  
키값은 하위 블록에 저장된 키값의 범위를 나타낸다.  
예를들어 루트 블록 30레코드가 가르키는 왼쪽 하위블록에는 30보다 작거나 같은 키값이 저장되어있다.  
### Leaf
- 리프 블록에 저장된 각 레코드는 키값 순으로 정렬이 되어있고 각 레코드마다 '테이블 레코드'를 가르키는 주소값(ROWID)를 가지고 있다.  
- 만약 인덱스 키값이 같으면 ROWID순으로 정렬된다.  
- 인덱스를 스캔하는 이유는 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해서다  
- ROWID는 아래와 같이 데이터 블록 주소(DBA, Data Block Address)와 로우 번호로 구성되므로 이 값을 알면 테이블 레코드를 찾아갈 수 있다.

-> ROWID = 데이터 블록 주소 + 로우 번호
-> 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
-> 블록 번호 = 데이터 파일 내에서 부여한 순번
-> 로우 번호 = 블록 내 순번
### LMC(Leftmost Child)
루트와 브랜치노드에는 특별한 키값을 가지지 않는 엔트리가 하나 있다.  
그 엔트리를 LMC라고 하며 노드의 첫번째 값으로 키값을 가진 첫번째 엔트리 보다 작은 값 이라는 의미를 가져  
해당 노드의 자식 노드중 가장 왼쪽 끝에 위치한 블록을 가르킨다.  
얘가 가지는 값은 첫번째 레코드보다 작거나 같은 레코드가 저장되어 있다. 
->  크게 중요해보이는 내용은 아닌듯 하여 따로 뺐습니다.  
# 인덱스의 탐색
- 수직적 탐색  
- 수평적 탐색  
## 수직적 탐색
정렬된 인덱스 레코드중 조건을 만족하는 첫번째 레코드를 찾는 과정이다.  
즉 인덱스의 스캔 지점을 찾는 과정이다.  
수직적 탐색 과정은 루트블록에서부터 시작한다.  
탐색 과정에서 찾고자 하는 값보다 크거나 같은 값을 만나면 바로 직전 레코드가 가르키는 하위 블록으로 이동한다.  
![Untitled Diagram drawio](https://user-images.githubusercontent.com/23313008/164605065-b676ff35-8b76-4c36-bd0a-e0f490817ef0.png)  
- 수직적 탐색에서의 핵심 내용은 조건을 만족하는 레코드를 찾는 과정이 아니다.
- 조건을 만족하는 '첫번째' 레코드를 찾는 과정이다.
- 책에서는 이정표로 비교했다.
## 수평적 탐색
수직적 탐색을 통해 스캔 시작점을 찾았으면 찾고자 하는 데이터가 나타나지 않을떄까지 리프  블록을 수평적으로 스캔한다.  
인덱스 탐색에서 본격적으로 데이터를 찾는 과정이다.
![Untitled Diagram](https://user-images.githubusercontent.com/23313008/164605585-c4d768be-ffea-48f7-9af8-be47a779b047.jpg)   
- 리프 블록 끼리는 서로 앞 뒤 블록에 대한 주소값을 가지고 있음 (Double LinkedList)  
### 인덱스를 수평적으로 탐색하는 이유
 - 조건절을 만족하는 데이터를 모두 찾기 위해
 - ROWID를 얻기 위해
 필요한 컬럼을 인덱스가 모두 가지고 있어 인덱스만 스캔하고 끝나는 경우도 있지만  
 일반적으로 인덱스를 스캔하고 테이블에도 액세스 하기 때문에 ROWID가 필요함  
 ### 결합 인덱스 구조와 탐색
 - 인덱스가 두개 이상으로 구성된 것
 - 선택도가 낮은 컬럼을 앞으로 두고 결합 인덱스를 생성해야 성능에 유리
 ![page21](https://user-images.githubusercontent.com/23313008/164608249-eb55f79f-16b2-47e8-b912-c72ed4fe0cdd.jpeg)  
 출처 http://wiki.gurubee.net/pages/viewpage.action?pageId=26739921  
 책에 나와있는 그림은 좀 헷갈려서 인터넷에서 따로 퍼왔습니다.  
 결합 인덱스의 핵심은 A이면서 B인 레코드를 찾는것이다.  
 인덱스 선두 컬럼을 "="으로 검색할 땐 어느 컬럼을 인덱스 앞쪽에 두든 I/O갯수가 같으므로 성능도 똑같다.  

# CH.2 인덱스 기본
> 챕터2의 핵심내용은 수직적 탐색과 수평적 탐색
# 인덱스란
- 책에 있는 목차라고 생각하면 됩니다.
## 인덱스에 대한 현실세계 시나리오
어느 한 초등학교에서 홍길동이라는 학생을 '효율적으로' 찾으려고 한다.  
첫번째 방법으로는 1학년 1반부터 6학년 6반까지 다 돌면서 찾는 방법이 있겠고  
두번재 방법으로는 교무실에 찾아가 학생명부를 보면서 홍길동이 있는 반을 찾아서 가는 방법이 있다.  
  
첫번재 방법은 Table Full Scan이고 홍길동이라는 이름을 가진 학생의 수가 많을 경우 더 효율적이고  
두번째 방법은 Index Range Scan이며 홍길동이라는 이름을 가진 학생의 수가 적을 경우 더 효율적이다.  
![RealWorldExample2](https://user-images.githubusercontent.com/23313008/164471007-1819f39c-ce4d-4db7-a93b-730e3ba9c0d6.png)

만약 이름으로 학생을 찾는 '방문객'이 많다면 위 표처럼 이름순으로 정렬해놓는것이 편하다.  
이것이 인덱스고 학년-반 컬럼이 인덱스 ROWID에 해당한다.  
# 인덱스를 사용하는 이유
## 2가지의 검색방법
- 테이블 전체를 스캔한다 (풀스캔)
- 인덱스를 이용한다.
## 인덱스를 이용해야하는 경우
인덱스를 이용해야하는 경우 -> 소량의 데이터를 읽는 경우  
Index Range Scan을 통한 테이블 액세스는 랜덤 액세스와 Single Block I/O방식으로 스캔한다.  
그렇기때문에 대량의 데이터를 읽을 풀스캔 보다 불리할 수 밖에 없다.  
## 인덱스를 이용했을 때 불리해지는 경우
대량의 데이터를 읽는 경우 인덱스를 이용하는게 더 비효율적이다  
위에서 설명했듯 인덱스의 경우 Single Block I/O, 랜덤 액세스로 스캔을 한다.  
하지만 Table Full Scan의 경우 Multi Block I/O, 시퀀셜 액세스로 스캔을하기때문에  
대량의 데이터를 읽을 땐(또는 읽을 데이터가 일정량을 넘을 땐) Index Range Scan보다 Table Full Scan이 유리하다.  
# 인덱스 튜닝의 두가지 핵심요소
인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다.  
세부적인 인덱스 튜닝 방법으론 여러가지가 있겠지만 핵심은 크게 두가지로 나뉜다.  
- 인덱스 스캔 효율화 튜닝
- 랜덤 액세스 최소화 튜닝
### 인덱스 스캔 효율화 튜닝
![Untitled Diagram drawio](https://user-images.githubusercontent.com/23313008/164474074-958aff4f-4ace-4a8d-97eb-3585455fec37.png)  
학생명부에서 시력이 '1.0-1.5' 사이인 '홍길동' 학생을 찾는 경우 이름과 시력순으로 정렬해두었다면 위 표와같이 소량만 스캔하면 된다  
반면 시력과 이름순으로 정렬해두었으면 똑같이 두명을 찾는데도 다음과 같이 많은양을 소비한다.  
![Untitled Diagram drawio-3](https://user-images.githubusercontent.com/23313008/164475092-8828213f-0aae-4858-bd2d-c806b3d9c566.png)  

### 랜덤 액세스 최소화 튜닝
인덱스 스캔후 테이블 레코드를 액세스 할 때 랜덤 I/O방식을 사용한다. 그래서 이를 튜닝 하는것이  
'랜덤 액세스 최소화' 튜닝이라고 한다.  
다시 '인덱스 스캔 효율화 튜닝'에서 들었던 예제를 생각해보자    
시력이 1.0-1.5인 홍길동 학생을 찾아야하는경우에 이름으로 정렬된 인덱스와 시력으로 정렬된 인덱스가 있다고 가정해보자  
그리고 시력이 1.0-1.5인 학생은 50명이고 홍길동 학생은 5명이다.    
그러면 어떤것을 선택해야할까?  
정답은 이름으로 정렬된 인덱스를 선택해야한다.    
시력 인덱스를 선택해서 검색을 한다고 가정해보면 50번의 교실을 찾아가야한다.  
반면에 이름으로 정렬된 인덱스를 선택하면 5번만 교실로 찾아가면 된다.  
즉 랜덤 액세스 튜닝의 핵심은 교실을 찾아가는 횟수를 줄이는것이다.  
-> 여기서 말하는 '교실로 찾아간다'는 인덱스 스캔 후 테이블 액세스를 뜻함.
   
인덱스 효율화 튜닝과 랜덤 액세스 최소화 튜닝은 둘다 중요하지만 더 중요한 하나를 고른다고 하면 랜덤 엑세스 튜닝이다.  
학생명부를 뒤지는(인덱스 스캔) 과정에도 비효율이 있을 수 있지만 인덱스에 없는 정보를 찾기위해 테이블에 접근하는것만 못하다.  
-> 책에서 설명하는 결론: 'SQL튜닝은 랜덤 I/O와의 전쟁이다.' (인덱스에만 국한되지 않음.) 
# 인덱스 구조
![bookindex](https://user-images.githubusercontent.com/23313008/164478224-24f3c6bd-d539-41b4-a5a2-2d71400c53c2.png)
![Youtubue](https://user-images.githubusercontent.com/23313008/164478531-17d0d97e-ad36-4c36-b650-af026e1cd18a.png)  
실생활에서 쓰이는 인덱스의 예제를 가져와봤다.  
만약 내가 트리를 공부하고싶은데 색인 페이지가 없다면 모든 페이지를 다 뒤져서 찾아야한다.  
또한 내가 듣고싶은 노래가 있는데 색인 정보가 없다면 10초씩 넘기면서 내가 듣고싶은 노래가 나올때까지 찾아야한다.  
하지만 색인이 있다면 200~230페이지를 펴서 보면된다 그리고 바로 시간을 클릭해서 노래를 들으면 된다.  
즉 인덱스를 이용한다면 범위 스캔(Range Scan)이 가능하다.  범위 스캔이 가능한 이유는 인덱스가 정렬되어있기 때문이다.  
그러면 인덱스의 구조는 어떻게 되어있을까?  
- 보통의 DBMS에서 인덱스는 b+tree 자료구조를 가지고있다 (Mysql InnoDB!)
- Root, Branch, Leaf 노드가 있다.  
- 루트와 브랜치블록에 있는 각 레코드는 하위 블록에 대한 주소값을 가지고 있다.
![btree](https://user-images.githubusercontent.com/23313008/164485061-4d3f79ef-5ca6-4d4d-8ace-a4e414ce6b4e.png)  
(출처) https://ssup2.github.io/theory_analysis/B_Tree_B+_Tree/  
위 그림에서 트리 꼭대기에 있는 노드는 '루트'이고 루트 밑에 있는 노드들은 '브랜치'이며 브랜치 아래에 있는 노드들은 '리프'이다.  
루트와 브랜치 블록에 있는 각 레코들은 하위 블록에 대한 주소값을 가지고 있다.  
키값은 하위 블록에 저장된 키값의 범위를 나타낸다.  
예를들어 루트 블록 30레코드가 가르키는 왼쪽 하위블록에는 30보다 작거나 같은 키값이 저장되어있다.  
### Leaf
- 리프 블록에 저장된 각 레코드는 키값 순으로 정렬이 되어있고 각 레코드마다 '테이블 레코드'를 가르키는 주소값(ROWID)를 가지고 있다.  
- 만약 인덱스 키값이 같으면 ROWID순으로 정렬된다.  
- 인덱스를 스캔하는 이유는 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해서다  
- ROWID는 아래와 같이 데이터 블록 주소(DBA, Data Block Address)와 로우 번호로 구성되므로 이 값을 알면 테이블 레코드를 찾아갈 수 있다.

-> ROWID = 데이터 블록 주소 + 로우 번호
-> 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
-> 블록 번호 = 데이터 파일 내에서 부여한 순번
-> 로우 번호 = 블록 내 순번
### LMC(Leftmost Child)
루트와 브랜치노드에는 특별한 키값을 가지지 않는 엔트리가 하나 있다.  
그 엔트리를 LMC라고 하며 노드의 첫번째 값으로 키값을 가진 첫번째 엔트리 보다 작은 값 이라는 의미를 가져  
해당 노드의 자식 노드중 가장 왼쪽 끝에 위치한 블록을 가르킨다.  
얘가 가지는 값은 첫번째 레코드보다 작거나 같은 레코드가 저장되어 있다. 
->  크게 중요해보이는 내용은 아닌듯 하여 따로 뺐습니다.  
# 인덱스의 탐색
- 수직적 탐색  
- 수평적 탐색  
## 수직적 탐색
정렬된 인덱스 레코드중 조건을 만족하는 첫번째 레코드를 찾는 과정이다.  
즉 인덱스의 스캔 지점을 찾는 과정이다.  
수직적 탐색 과정은 루트블록에서부터 시작한다.  
탐색 과정에서 찾고자 하는 값보다 크거나 같은 값을 만나면 바로 직전 레코드가 가르키는 하위 블록으로 이동한다.  
![Untitled Diagram drawio](https://user-images.githubusercontent.com/23313008/164605065-b676ff35-8b76-4c36-bd0a-e0f490817ef0.png)  
- 수직적 탐색에서의 핵심 내용은 조건을 만족하는 레코드를 찾는 과정이 아니다.
- 조건을 만족하는 '첫번째' 레코드를 찾는 과정이다.
- 책에서는 이정표로 비교했다.
## 수평적 탐색
수직적 탐색을 통해 스캔 시작점을 찾았으면 찾고자 하는 데이터가 나타나지 않을떄까지 리프  블록을 수평적으로 스캔한다.  
인덱스 탐색에서 본격적으로 데이터를 찾는 과정이다.
![Untitled Diagram](https://user-images.githubusercontent.com/23313008/164605585-c4d768be-ffea-48f7-9af8-be47a779b047.jpg)   
- 리프 블록 끼리는 서로 앞 뒤 블록에 대한 주소값을 가지고 있음 (Double LinkedList)  
### 인덱스를 수평적으로 탐색하는 이유
 - 조건절을 만족하는 데이터를 모두 찾기 위해
 - ROWID를 얻기 위해
 필요한 컬럼을 인덱스가 모두 가지고 있어 인덱스만 스캔하고 끝나는 경우도 있지만  
 일반적으로 인덱스를 스캔하고 테이블에도 액세스 하기 때문에 ROWID가 필요함  
 ### 결합 인덱스 구조와 탐색
 - 인덱스가 두개 이상으로 구성된 것
 - 선택도가 낮은 컬럼을 앞으로 두고 결합 인덱스를 생성해야 성능에 유리
 ![page21](https://user-images.githubusercontent.com/23313008/164608249-eb55f79f-16b2-47e8-b912-c72ed4fe0cdd.jpeg)  
 출처 http://wiki.gurubee.net/pages/viewpage.action?pageId=26739921  
 책에 나와있는 그림은 좀 헷갈려서 인터넷에서 따로 퍼왔습니다.  
 결합 인덱스의 핵심은 A이면서 B인 레코드를 찾는것이다.  
 인덱스 선두 컬럼을 "="으로 검색할 땐 어느 컬럼을 인덱스 앞쪽에 두든 I/O갯수가 같으므로 성능도 똑같다.  
# 인덱스 기본 사용법
- Index Range Scan
- Index Full Scan
### Index Range Scan
- 결합 선택도
- 결합 인덱스
- 결합 파티셔닝
- 글로벌 비파티션 인덱스
- 글로벌 인덱스
- 글로벌 파티션 인덱스
- 논리적 최적화
- 높이 균형 히스토그램  
위 리스트에서 '글로벌'로 시작하는 단어를 찾아보자  
순간적인 눈동작으로 시작지점을 바로 찾을 수 있었을 것이다.(수직적 탐색)  
다른 예시로 '인덱스'를 포함하는 단어를 찾아보자  
앞에서 본 글로벌을 찾는 경우와 어떤점이 다르냐면 시작점을 찾을 수 없다는 점이 다르다.  
### 인덱스 시작점을 찾을 수 없는 경우
- 가공된 값
- 중간에 포함된 값 (%문자열%)  
이 경우 Index Full Scan 해야한다.  
### 인덱스를 정상적으로 사용한다는 의미
- 리프블록에서 스캔 지점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미
- 이것이 Index Range Scan
### 인덱스의 컬럼을 가공했을 때 범위 스캔을 사용할 수 없는 이유
- 시작점을 찾을 수 없기 때문
- Range Scan을 하려면 시작과 끝 지점이 있어야함
### 정리
- 인덱스를 정상적으로 사용한다는 것은 리프블록에서 스캔 시작점을 찾아 거기서부터 스캔 하다가 중간에 멈추는 것을 의미    
아래와 같은 경우 인덱스를 정상적으로 태울 수 없음.  
```sql
where substr(생년월일, 5, 2) = '05'  
where nvl(주문수량, 0) < 100
where 업체명 like %대한%
where (전화번호 = :tel_no or 고객명 = :cust_nm)
where 전화번호 in (:tel_no, :tel_no2)
```   
## 중요한 인덱스 사용 조건
- 인덱스의 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 함
기준연도 + 과세구분코드 + 보고회차 + 실명확인번호 로 인덱스를 지정했다고 칩시다.  
```sql
where 기준연도 = :year and substr(과세구분코드, 1, 4) = :txtn_dcd ~~
```
위 sql은 가공된 데이터가 조건절에 들어가있는데 어떻게 Index Range Scan이 가능한걸까?  
바로 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있기 때문이다.  
하지만 Range Scan을 한다고 모두 성능이 좋은것은 아니다.  
> 인덱스를탄다 == Index Range Scan
인덱스를 가공해도 인덱스를 사용할 순 있지만 찾고자 하는 데이터가 전 구간에 흩어져 있기 떄문에 Range 스캔이 불가능해진다.  
### Index Range Scan을 하여도 성능이 안나오는 경우
```sql
    SELECT * FROM A WHERE 주문일자 = :ord_dt AND 상품번호 LIKE '%PING%';  
    SELECT * FROM A WHERE 주문일자 = :ord_dt AND SUBSTR(상품번호, 1, 4) LIKE 'PING';
```  
위 SQL은 인덱스를 타긴 탄다. 선두 컬럼은 가공되지 않았고 스캔 시작점을 찾아 중간에 멈출 수 있다.  
그런 의미에선 인덱스를 잘 탄다고 할수 있지만 정말 잘타는지는 리프 블록에서 스캔하는 양을 봐야 알 수 있다.  
> 위 SQL에서 상품번호는 스캔 범위를 줄이는데 전혀 역할을 하지 못함.
> 첫번째 SQL은 중간값 검색이고 두번째는 컬럼을 가공했기 때문
### Index를 이용한 소트 연산 생략
- 인덱스를 Range Scan할 수 있는 이유는 데이터가 정렬되어있기 때문
테이블과 달리 인덱스는 정렬되어있기 때문에 Range Scan이 가능하고 정렬 효과도 부수적으로 얻게 됌  
```sql
SELECT * FROM 상태변경이력 WHERE 장비번호 = 'C' and 변경일자 = '20210423' ORDER BY 변경순번
```
위와 같은 쿼리가 있다고 가정해보자.  
sql 옵티마이저는 Index가 정렬되어있는 특성을 이용해서 ORDER BY 절이 있어도 정렬 연산을 따로 수행하지 않는다.  
- ASC(오름차순)정렬일 땐 조건을 만족하는 가장 작은 값을 찾아 죄측으로 수직적 탐색한 후 우측으로 수평적 탐색을 한다.
- DESC(내림차순)정렬일 땐 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색한 후 좌측으로 수평적 탐색을 한다.
## ORDER BY 절에서 컬럼 가공
- ORDER BY절이나 SELECT-LIST에서도 컬럼을 가공하게되면 인덱스를 정상적으로 사용할 수 없게 되는 경우도 있다.
### case 1  
```sql
SELECT * FROM 상태변경이력 WHERE 장비번호 = 'C' ORDER BY 변경일자 || 변경순번
```
위와같은 경우이다.
### case2
```sql
SELECT * FROM (
    SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액
        FROM 주문 A
        WHERE A.주문일자 = :dt
        AND A.주문번호 > NVL(:next_ord_no, 0)
        ORDER BY 주문번호
)
WHERE ROWNUM <= 30
```
위에서는 ORDER BY절에 기술한 주문번호가 순수한 주문번호가 아닌 TO_CHAR로 가공한 주문번호이기 때문에  
위를 개선하려면 A.주문번호로 바꿔주면 된다.  

## SELEC-LIST에서 컬럼 가공
> 정렬 연산을 생략할 수 있는지가 포인트
### 정렬 연산을 생략할 수 있는 SELECT-LIST 컬럼 가공
```sql
SELECT MIN(변경순번) FROM 상태변경이력 WHERE 장비번호 = 'C' AND 변경일자 = '20180316'
SELECT MAX(변경순번) FROM 상태변경이력 WHERE 장비번호 = 'C' AND 변경일자 = '20180316'
```
인덱스를 장비번호 + 변경일자 + 변경순번 순으로 구성하면 위와같이 변경순번의 최소, 최대 값을 구할 때도  
옵티마이저는 따로 정렬 연산을 수행하지 않음  
수직적 탐색을 통해 조건을 만족해서 읽는 첫번째가 최소, 최대값이기 때문이다.  
### 정렬 연산을 생략할 수 없는 SELECT-LIST 컬럼 가공
```sql
SELECT NVL(MAX(TO_NUMBER(변경순번)), 0) FROM 상태변경이력 WHERE 장비번호 = 'C' AND 변경일자 = '20180315'
```
위의 쿼리는 생략이 안되는 이유는 인덱스는 문자열 기준으로 정렬되어있는데 이를 숫자값으로 바꾼 값 기준으로 최종 변경순번을 요구했기 때문  
```sql
SELECT NVL(TO_NUMBER(MAX(변경순번)), 0) FROM 상태변경이력 where 장비번호 = 'C' AND 변경이력 ='20180315'
```
위의 쿼리는 정상적으로 실행이 가능하다. 문자열 기준으로 검색을 한 뒤 숫자로 바꿔주기 때문이다.  
## 자동형변환
고객 테이블에 생년월일(문자열)이 선두 컬럼인 인덱스가 있다고 치자  
```sql
SELECT * FROM 고객 WHERE 생년월일 = 20000507
```
위 쿼리에서 조건절을 가공하지 않아도 Index Full Scan으로 작동한다.  
이유는 생년월일은 문자형으로 되어있는데 조건절에서는 정수형으로 비교했기 때문이다.  
그래서 옵티마이저는 자동 형변환을 시도했고 결과적으로 Range Scan을 할 수 없었기 때문이다.  
TO_NUMBER(생년월일) = 20000507  
- 숫자와 문자형이 만나면 숫자형이 우선순위가 높음
- LIKE 연산자의 경우 문자열 비교 연산자 이므로 이때는 문자형 기준으로 숫자형 컬럼이 변환된다.
> 컬럼 타입의 설계와 실수하지 않는것이 중요함
> 자동 형변환이라는 키워드를 알고있는것이 중요
### 자동형변환 주의
- 숫자형 컬럼과 문자형 컬럼을 비교하면 문자형 컬럼이 숫자로 형변환 된다.
- 만약 문자형 컬럼에 숫자로 변경할 수 없는 문자열이 입력되는 쿼리 수행 도중 에러 발생
### 결론
- 자동 형변환에 의존하지 말고 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확하게(명시적으로) 형변환 해줘야한다.  
- 개발자가 형변환 함수를 생략해도 옵티마이저가 자동 생성함.
- 설계를 잘하자
### 착각
TO_CHAR, TO_DATE, TO_NUMBER같은 형변환 함수를 사용한다고 성능저하가 크게 발생되는것이 아니다.  
SQL성능은 블록 I/O를 줄일 수 있냐 없냐에서 결정된다.
# NL 조인
NL조인은 2중포문과 같은 구조로 탐색한다.  
OUTER 쪽 테이블 크기가 크지 않으면 인덱스를 이용하지 않을 수 있다.  
OUTER쪽 테이블을 Full Scan하더라도 그것은 한번에 그칠 수 있기 때문이다.  
반면 Inner쪽 테이블은 인덱스를 사용한다.  
Inner쪽에서 풀스캔이 발생하게 되면 Outer쪽에서 읽은 건수만큼 Inner테이블에 Full Scan이 발생하기 떄문이다.  
## 동작 방식 그림
![무제](https://user-images.githubusercontent.com/23313008/166653240-b441864b-c55c-4d92-8dde-5774d981a8cd.png)  
NL 조인은 다음과 같다.
사원 테이블과 사원이 관리하는 고객관리 테이블이 있다고 치자.  
OUTER 테이블은 사원 테이블이고 Inner 테이블은 고객관리 테이블이다.  
1. OUTER 테이블의 사원 인덱스를 스캔하여 OUTER 테이블의 레코드를 찾는다.
2. 사원 인덱스에서 읽은 ROWID로 사원 테이블을 찾아간다.  
3. 사원 테이블에서 읽은 사원번호 '3'번으로 고객관리 인덱스에서 탐색한다.
4. 고객관리 인덱스에서 찾은 사원번호 '3'으로 고객관리 테이블을 찾아간다.
5. 고객관리 테이블을 스캔하다가 '3' 보다 큰 번호가 나왔으므로 스캔을 중지한다.
6. 위 과정을 반복한다.
# NL 조인 수행과정 분석
```sql
select /*+ ordered use_nl(c) index(e) index(c) */
    e.사원번호, e.사원명, e.입사일자, c.고객번호, c.고객명, c.전화번호, c.최종주문금액
    from 사원 e, 고객 c
    where c.관리사원번호 = e.사원번호 // 1
    and e.입사일자 >= '19960101' // 2
    and e.부서코드 = 'Z123' // 3
    and c.최종주문금액 >= 20000 // 4 
```
### 인덱스 구성은 다음과 같다.
```plain
* 사원_PK : 사원번호
* 사원_X1 : 입사번호
* 고객_PK : 고객번호
* 고객_X1 : 관리사원번호
* 고객_X2 : 최종주문금액
```
두 테이블에 인덱스 힌트를 명시해씅므로 둘 다 인덱스를 이용해서 액세스한다.    
인덱스며은 명시하지 않았으므로 어떤 인덱스를 사용할지는 옵티마이저가 결정한다.  
SQL 조건절 우측에 표시한 번호로 비교순서를 나열하면 2->3->1->4 순이다.  

1. 조건절 번호 2: 입사일자 >= '19960101' 조건을 만족하는 사원을 찾으려고 사원_X1 인덱스를 Range Scan한다.
2. 조건절 번호 3: 사원 인덱스를 스캔하여 얻은 ROWID로 사원 테이블을 액세스해서 부서코드 = 'Z123'필터 조건을 만족하는지 확인한다.  
3. 조건절 번호 1: 사원 테이블에서 읽은 사원번호 값으로 조인 조건 (c.관리자사원번호 = e.사원번호)을 만족하는 고객 쪽 레코드를 찾으려고 고객_X1 인덱스를 Range 스캔한다.
4. 조건절 번호 4: 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블을 액세스해서 최종주문금액 >= 20000 필터 조건을 만족하는지 확인한다.
> 각 단계를 모두 완료하고 다음 단계로 넘어가는것이 아니라 한 레코드씩 순처적으로 진행한다는 사실이다.  
![nl_실행과정](https://user-images.githubusercontent.com/23313008/166657768-652fcca4-934f-4fe8-a1cf-e73742857447.jpeg)  
위 그림을 번호순대로 차근차근 따라가보라.  
# NL 조인 튜닝포인트
### 사원_X1을 읽고 나서 사원 테이블을 액세스 하는 부분
만약 사원 테이블로 아주 많은 양의 랜덤 액세스가 발생했고 테이블에서 부서코드 = 'Z123'조건에 필터링 되는 비율이 높다면  
사원_X1 인덱스에 부서코드를 추가하는 방안을 고려해야 한다.  
### 고객_X1 인덱스를 탐색하는 부분
고객_X1 인덱스를 탐색하는 횟수, 즉 조인 액세스 횟수가 많을수록 성능이 느려진다.  
조인 액세스 횟수는 Outer 테이블인 사원을 읽고 필터링한 결과 건수에 의해 결정된다.  
위 (NL 조인 수행 탐색과정 분섣)에 SQL에서는 부서코드 = 'Z123' 조건을 만족하는 컬럼이 3건이 있고 3번의 조인 시도가 발생했다.  
만약 부서코드 조건을 만족하는 레코드가 10만건이고 고객_X1 인덱스 Depth가 3이라면 인덱스 수직적 탐색 과정에서만 30만개 블록을 읽어야하고  
수평 탐색 과정에서는 추가적인 블록 I/O가 더해진다.  
### 고객_X1 인덱스를 읽고 나서 고객 테이블을 액세스 하는 부분
최종주문금액 >= 20000 조건에 의해 필터링 되는 비율이 높다면 고객_X1 인덱스에 최종주문금액 컬럼을 추가하는 방안을 고려해야한다.  
> 마지막으로, 맨 처음 액세스하는 사원_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우된다는 사실도 기억하기 바란다.  
# NL 조인 특징
- 랜덤 액세스 위주 조인 방식
- 랜덤 액세스 방식이기 때문에 인덱스 구성이 잘되어있어도 대량 데이터 조인시 NL조인이 불리한 이유가 이것때문.
- 한 레코드씩 순처적으로 진행한다.
- 첫번째 특징 때문에 대량 데이터 조인시 한계를 드러내지만 이 두 번째 특징 덕에 아무리 큰 테이블을 조인하더라도 매우 빠른 응답속도를 낼 수 있음 (부분범위처리가 가능한 상황에서만)
- 인덱스 구성 전략이 중요함
> NL조인은 소량 데이터를 주로 처리하거나 부분범위 처리가 가능한 OLTP시스템에 적합한 조인 방식
# NL조인 확장 메카니즘
> 버전이 올라가면서 오라클 데이터베이스는 NL조인 성능을 높이기 위해 테이블 Prefetch와 배치 I/O기능을 도입했다.  
### 테이블 Prefetch
- 인덱스를 이용해 테이블을 액세스 하다가 디스크 I/O가 필요해지면 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능  
### 배치 I/O
- 디스크 I/O를 미뤘다가 읽는 블록이 일정량 쌓이면 한꺼번에 처리하는 기능
> 두 기능 다 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안되었다.  
# 소트 머지 조인
- 조인 테이블에 인덱스가 없을 때 옵티마이저는 소트 머지 조인이나 해시 조인을 선택한다.  
- 해시조인의 등장으로 소트 머지 조인의 쓰임새가 예전만 못하지만 해 조인을 사용할 수 없는 상황에서 대량 데이터를 조인하고자 할 때 여전히 유용함.
- 소트 머지 조인과 해시 조인을 설명하려면 PGA에 대한 설명이 선행되어야 한다.
## SGA vs PGA
### SGA
- 공유 메모리 영역인 SGA에 캐시된 데이터는 여러 프로세스가 공유할 수 있다.
- 여러 프로세스가 공유할 수 있지만 동시에 액세스할 수는 없다.
- 동시에 액세스하려는 프로세스 간 액세스를 직렬화 하기 위한 Lock 매커니즘으로 Latch가 존재한다.
- 데이터 블록과 인덱스 블록을 캐싱하는 DB 버퍼캐시는 SGA의 가장 핵심적인 구성요소.
(버퍼캐시, 인덱스 블록, 데이터 블록은 SGA 구성요소)  
- 버퍼캐시에서 블록을 읽으려면 버퍼 Lock을 얻어와야함
### PGA
- 데이터베이스에 접속하는 모든 유저에게 할당되는 각각의 서버 프로세스가 독자적으로 사용하는 오라클 메모리 영역
- 다른 프로세스와 공유하지 않는 독자적인 메모리 공간을 가짐.
- 따라서 래치 매커니즘이 불필요함
- 같은 양의 데이터를 읽더라도 SGA 버퍼캐시에서 읽을 때보다 훨씬 빠르다.
## 소트 머지 조인의 기본 매커니즘
1. 소트 단계: 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
2. 머지 단계: 정렬한 양쪽 집합을 서로 머지 한다.
```sql
select /*+ ordered use_merge(c) */
    e.사원번호, e.사원명, e.입사일자,
    c.고객번호, c.고객명, c.전화번호, c.최종주문금액
from 사원 e, 고객 c
where c.관리사원번혼 = e.사원번호
and e.입사일자 >= '19960101'
and e.부서코드 = 'Z123'
and c.최종주문금액 >= 20000
```
### 소트 단계
1. 조건절에 맞는 사원 데이터를 읽어 조인 컬럼인 사원번호 순으로 정렬한다. 정렬한 결과집합은 PGA영역에 할당된 Sort Area에 저장한다.
2. 만약 결과집합이 Sort Area보다 크다면 Temp 테이블 스페이스에 저장한다
3. 고객 테이블도 똑같이 조건에 맞는 데이터를 읽어 조인 컬럼인 관리사원번호 순으로 정렬한다.
4. 만약 결과집합이 Sort Area보다 크다면 Temp 테이블 스페이스에 저장한다
### 머지 단계
5. PGA(또는 temp 테이블 스페이스)에 저장한 사원 데이터를 스캔하면서 PGA(또는 Temp 테이블 스페이스)에 저장한 고객 데이터와 조인한다.
> Sort Area에 저장한 데이터 자체가 인덱스 역할을 하므로 소트 머지 조인은 조인 컬럼에 인덱스가 없어도 사용할 수 있는 조인 방식이다,
## 소트 머지 조인이 빠른 이유
- NL 조인 단점은 대량의 데이터를 조회할 때 느리다는 단점이 있다.
- 소트 머지 조인은 PGA Sort Area에 미리 정렬해둔 자료구조를 이용한다는 점만 다를 뿐 조인 프로세스 자체는 NL조인과 같다.
> 그럼 대량데이터를 조회할 때 빠른이유는 뭘까?
- NL 조인은 인덱스를 이용한 조인방식이기 때문에 랜덤 액세스 I/O가 발생한다.
- 조인 과정에서 액세스하는 모든 블록을 랜덤 액세스 방식으로 버퍼캐시를 경유해서 읽는다.
- 반면 소트 머지 조인은 양쪽 테이블로부터 조인 대상 집합을 일괄적으로 읽어 PGA(또는 Temp 테이블스페이스)에 저장한 후 조인한다.
- PGA는 프로세스만을 위한 독립적인 메모리 공간이므로 데이터를 읽을 때 래치 획득을 할필요가 없다.
- 이것이 소트 머지 조인이 대량 데이터 조인에 더 유리한 이유이다.
## 소트 머지 조인의 주 용도
- 조인 조건식이 등치 조건이 아닌 대량 데이터 조인
- 조인 조건식이 아예 없는 조인 (Cross Join, 카타시안 곱)
## 소트 머지 조인 특징 요약
- 소트 머지 조인은 실시간으로 인덱스를 생성하는것과 다름 없다.
- 정렬한 다음에는 NL 조인과 같은 방식으로 진행하지만 PGA 영역에 저장한 데이터를 이용하기 때문에 빠르다
- 소트 부하만 감수한다면 건건이 버퍼캐시를 경유하는 NL 조인보다 빠르다.
- 소트 머지 조인은 인덱스 유무에 영향을 받지 않음.
- 양쪽 집합을 개별적으로 읽고 조인을 시작함
- 스캔위주 액세스 방식을 사용함
- 양쪽 소스 집합으로부터 조인 대상 레코드를 찾는데 인덱스를 이용할 수 있고. 이때 랜덤 액세스가 발생함
- 즉 모든 처리가 스캔방식으로 이루어지는건 아니라는 뜻.
# 해시 조인
- 소트 머지 조인과 해시 조인은 조인 과정에 인덱스를 이용하지 않기 때문에 대량 데이터를 조인할 때 NL조인보다 훨씬 빠르고 일정한 성능을 보임.
- 소트 머지 조인은 항상 양쪽 테이블을 정렬하는 부담이 있지만 해시 조인은 그런 부담은 없다.
- 그렇다고 모든 조인을 해시 조인으로 처리할 수는 없음
## 기본 매커니즘
1. Build 단계: 작은 쪽 테이블을 읽어 해시 테이블을 생성한다.
2. Probe 단계: 큰 쪽 테이블을 읽어 해시 테이블을 탐색하면서 조인한다.
> 한 집합의 테이블을 읽어서 해시테이블을 만들고 해시테이블을 읽으면서 조인한다.
![무제](https://user-images.githubusercontent.com/23313008/167251966-e33512a5-1fa3-4abe-90d5-528b962a50d7.png)  
## 해시 조인이 빠른 이유
- PGA 영역에 할당된 Hash Area에 생성한 해시 테이블을 이용한다는 점만 다를 뿐 프로세스 자체는 NL조인과 똑같다.
- 빠른 이유는 소트 머지 조인과 같다. PGA 영역에 할당되어있기 떄문이다. (Random Access X, 버퍼캐시 경유 X)
- 해시 조인도 Build Input, Probe Input 테이블을 읽을 때는 버퍼 캐시를 경유한다. 이때 인덱스를 이용하기도 함.
- 이 과정에서 생기는 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 해시 조인이라도 피할 수 없음.
## 소트 머지 조인보다 해시 조인이 빠른 이유
- 둘다 PGA에서 작업을 한다는것은 같은데 왜 해시조인이 더 빠를까(대량데이터 조회시)
- 성능차이는 조인 연산을 실행하기 전 사전 준비작업에 기인한다.
- 소트 머지 조인에서 사전 준비작업은 양쪽 집합을 모두 정렬해서 PGA에 올리는 작업이다.
- 하지만 PGA는 큰 메모리 공간이 아니므로 두 집합중 하나가 중대형크기 이상이면 Temp 테이블 스페이스에 올린다. (Disk I/O)
- 해시 조인에서 사전준비 작업은 두 집합중 어느 한쪽을 읽어 해시 맵을 만드는 작업이다.
- 해시 조인은 둘 중 작은 집합을 해시 맵 Build Input으로 선택하므로 두 집합 모두 Hash Area에 담을 수 없을 정도로 큰 경우가 아니면
- Temp 테이블 스페이스 즉 Disk I/O는 일어나지 않는다.
> 해시 조인은 양쪽 테이블을 정렬하는 부하도 없고 랜덤 액세스 부하도 없다.
> 둘중 작은 집합을 해시 테이블로 만드므로 대개는 부담이 크지 않다.
# 대용량 Build Input 처리
> 분할, 정복 방식으로 이루어진다.
### 1. 파티션 단계
- 조인하는 양쪽 집합의 조인 컬럼에 해시 함수를 적용하고 반환된 해시 값에 따라 동적으로 파티셔닝 한다.
- 독립적으로 처리할 수 있는 여러 개의 작은 서브 집합으로 분할함으로써 파티션 페어를 생성하는 단계다.
- 양쪽 집합을 읽어 디스크 Temp 공간에 저장해야 하므로 인메모리 해시 조인보다 성능이 많이 떨어진다.
### 2. 조인 단계
- 파티셔닝을 완료하면 각 파티션 페어에 대해 하나씩 조인을 수행한다.
- 이때, 각각에 대한 Build Input과 Probe Input은 독립적으로 결정된다.
- 즉 파티션하기 전 어느 쪽이 작은 테이블이었는지에 대해 상관없이 각 파티션 페어별로 작은쪽을 Build Input으로 선택하고 해시 테이블을 생성한다.
- 해시 테이블을 생성하고 나면 반대쪽 파티션 로우를 하나씩 읽으면서 해시 테이블을 탐색한다.
## 조인 메소드 선택 기준
1. 소량 데이터 조인시 -> NL 조인
2. 대량 데이터 조인시 -> 해시 조인
3. 대량 데이터 조인인데 해시 조인으로 처리할 수 없을 때(조인 조건식이 등치 조건이 아닐 때) -> 소트 머지 조인
### 소량과 대량의 기준
- NL 조인 기준 최적화 했음에도 불구하고 랜덤 액세스가 많아 만족할만한 성능을 낼 수 없다면 대량에 해당한다.
### 수행빈도가 높은 쿼리 선택 기준
- (최적화된) NL 조인과 해시 조인 성능이 같으면 -> NL 조인
- 해시 조인이 약간 더 빨라도 -> NL 조인
- NL 조인보다 해시 조인이 매우 빠른 경우 -> 해시 조인
## 왜 해시조인이 더 효율적임에도 불구하고 NL조인을 선택해야할까?
- NL 조인에 사용되는 인덱스는 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용 하는 자료구조다.
- 해시 테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 자료구조다.
- 같은 쿼리를 100개 프로세스가 동시에 수행하면 해시 테이블도 100개가 만들어진다.
- 따라서 수행시간이 짧으면서 수행빈도가 매우 높은 쿼리 (OLTP성 쿼리)를 해시 조인으로 처리하면 CPU와 메모리 사용률이 크게 증가한다.
- 해시 맵을 만드는 과정에서 여러 가지 래치 경합도 발생한다.
### 따라서 해시조인은 아래와 같은 경우에 사용한다.
1. 수행빈도가 낮고
2. 쿼리 수행 시간이 오래 걸리는
3. 대량 데이터를 조인할 때
> 즉 OLAP 성 쿼리에 쓰임 (배치 프로그램 등등...)
# 서브쿼리 조인
## 서브쿼리 변환이 필요한 이유
- 옵티마이저는 cost를 평가하고 실행계획을 생성하기 앞서 사용자로부터 전달받은 SQL을 최적화에 유리한 형태로 변환하는 작업, 즉 쿼리 변환부터 실행한다.
- 쿼리변환은 옵티마이저가 SQL을 분석해 같은 결과 집합을 생성하면서도 더 나은 성능이 기대되는 형태로 재작성 되는것을 말한다.
## 서브쿼리
1. Inline View: FROM 절에 사용한 서브쿼리
2. Nested Subquery: 결과집합을 한정하기 위해 Where절에 사용한 서브쿼리
3. Scalar Subquery: 한 레코드당 정확히 하나의 값을 반환하는 서브 쿼리
## 서브쿼리와 조인
> 메인쿼리와 서브쿼리에는 부모와 자식이라는 계층적이고 종속적인 곤계가 존재한다.
> 서브쿼리는 메인 쿼리에 종속되므로 단독으로 실행할 수 없다.
> 메인쿼리 건수 만큼 값을 받아 반복적으로 필터링하는 방식으로 실행해야한다.
### 필터 오퍼레이션
- 필터 오퍼레이션은 기본적으로 NL 조인과 처리 루틴이 같다.
- NL 조인처럼 부분 범위 처리도 가능하다.
- 차이가 있다면 필터는 메인쿼리의 한 로우가 서브쿼리의 한 로우와 조인에 성공하는 순간 진행을 멈추고 메인쿼리의
- 다음 로우를 계속 처리해야한다는 점이다.
- NL 조인과 다른 두 번째 차이점은 필터는 캐싱 기능을 갖는다는 점이다.
- 이는 필터처리한 결과, 즉 서브쿼리 입력 값에 따른 반환 값을 캐싱하는 기능이다.
- 이 기능이 작동하므로 서브쿼리를 수행하기 전에 항상 캐시부터 확인한다.
- 캐싱은 쿼리 단위로 이루어진다. 쿼리를 시작할 때 PGA 메모리에 공간을 할당하고 쿼리를 수행하면서 공간을 채워나가며 쿼리를 마치는 순간 공간을 반환한다.
- 마지막으로 필터 서브쿼리는 일반 NL 조인과 달리 메인 쿼리에 종속되므로 조인 순서가 고정된다.
### 쿼리 Unnesting
- 서브쿼리 Unnesting은 메인과 서브쿼리 간의 계층구조를 풀어 서로 같은 레벨(flat한 구조)로 만들어준다는 의미에서 서브쿼리 Flatting이라고 부르기도 함
- 서브쿼리를 Unnesting해서 메인 쿼리와 같은 레벨로 만들면 다양한 조인 메소드를 선택할 수 있고
- 조인 순서도 마음껏 정할 수 있다.
### 서브쿼리 Pushing
- Unnesting 되지 않은 서브쿼리는 항상 필터 방식으로 처리되며, 대개 실행계획 상에서 맨 마지막 단계에 처리된다.
- 서브쿼리 필터링을 가능한 한 앞 단계에서 처리하도록 강제하는 기능
- 이 기능은 Unnesting 되지 않은 서브쿼리에만 작동
### View와 조인
- 최적화 단위가 쿼리 블록이므로 옵티마이저가 뷰 쿼리를 변환하지 않으면 뷰 쿼리 블록을 독립적으로 최적화한다.
### 조인 조건 Pushdown
- 메인 쿼리를 실행하면서 조인 조건절 값을 건건이 뷰 안으로 밀어 넣는 기능이다.
- 아래 실행계획에 나타난 View pushed predicate 오퍼레이션을 통해 이 기능의 작동여부를 알 수 있음
## 스칼라 서브쿼리 조인
### 스칼라 서브쿼리 특징
- 스칼라 서브쿼리는 메인쿼리 레코드마다 정확히 하나의 값만 반환한다.
- 메인 쿼리 건수만큼 테이블을 반복해서 읽는다는 측면에서 함수와 비슷해보이지만 함수처럼 재귀적인 구조는 아니다.
- 컨텍스트 스위칭 없이 메인쿼리와 서브쿼리를 한 몸체처럼 실행한다.
- 스칼라 서브 쿼리는 처리 과정에서 캐싱 작용이 일어난다.
### 스칼라 서브쿼리의 캐싱 효과
- 스칼라 서브쿼리로 조인하면 오라클은 조인 횟수를 최소화 하려고 입력 값과 출력 값을 내부 ㅋ내시에 저장해둔다.
- 조인할 때 마다 캐시에서 입력값을 찾아보고 찾으면 저장된 출력 값을 반환한다.
- 캐시에서 찾지 못할때만 조인을 수행하며 결과는 버리지 않고 캐시에 저장해둔다.
- 스칼라 서브쿼리의 입력 값은 그 안에서 참조하는 메인 쿼리의 컬럼 값이다.
- 캐싱은 쿼리 단위로 이루어진다.
- 쿼리를 시작할 때 PGA 메모리에 공간을 할당하고 쿼리를 수행하면서 공간을 채워나가며 쿼리를 마치는 순간 공간을 반환한다.
### 스칼라 서브쿼리 캐싱의 부작용
- 모든 캐시가 다 그렇듯, 캐시 공간은 늘 부족하다.
- 오라클 8i, 9i 기준으로 256개의 엔트리를 캐싱하고, 10g 이후로는 입력값과 출력값 크기, _query_execution_cache_max_size
- 파라미터에 의해 사이즈를 결정한다.
- 결론적으로 스칼라 서브쿼리 캐싱 효과는 입력 값의 종류가 소수여서 해시 충돌 가능성이 작을 때 효과가 있음
- 반대의 경우 캐시를 매번 확인하는 비용 덕에 오히려 성능이 나빠지고 CPU, 메모리 사용률만 높게 만든다.
### 2개이상 값 반환시
- 스칼라 서브쿼리는 2개이상 값을 반환할 수 없다.
- SQL 튜너들이 전통적으로 사용해온 방식은 구하는 값들을 문자열로 모두 결합하고 바깥쪽 액세스 쿼리에서
- substr로 다시 분리하는 방식이다.
- 두 개 이상의 값을 반환하고 싶을 때 이런저런 고민 없이 아래와 같이 인라인 뷰를 사용하면 편하긴 하다.
### 스칼라 서브쿼리 Unnesting
- 스칼라 서브쿼리도 NL 방식으로 조인하므로 캐싱 효과가 크지 않으면 랜덤 I/O 부담이 있다.
- 그래서 다른 조인 방식을 선택하기 위해 스칼라 서븤눠리를 일반 조인문으로 변환하고 싶을때가 있다.
- 특히 병렬 쿼리에선 될 수 있으면 스칼라 서브쿼리를 사용하지 않아야 한다.
- 대량 데이터를 처리 하는 병렬 쿼리는 해시 조인으로 처리해야 효과적이기 때문이다.
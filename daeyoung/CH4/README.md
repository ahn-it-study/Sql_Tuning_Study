# NL 조인
NL조인은 2중포문과 같은 구조로 탐색한다.  
OUTER 쪽 테이블 크기가 크지 않으면 인덱스를 이용하지 않을 수 있다.  
OUTER쪽 테이블을 Full Scan하더라도 그것은 한번에 그칠 수 있기 때문이다.  
반면 Inner쪽 테이블은 인덱스를 사용한다.  
Inner쪽에서 풀스캔이 발생하게 되면 Outer쪽에서 읽은 건수만큼 Inner테이블에 Full Scan이 발생하기 떄문이다.  
## 동작 방식 그림
![무제](https://user-images.githubusercontent.com/23313008/166653240-b441864b-c55c-4d92-8dde-5774d981a8cd.png)  
NL 조인은 다음과 같다.
사원 테이블과 사원이 관리하는 고객관리 테이블이 있다고 치자.  
OUTER 테이블은 사원 테이블이고 Inner 테이블은 고객관리 테이블이다.  
1. OUTER 테이블의 사원 인덱스를 스캔하여 OUTER 테이블의 레코드를 찾는다.
2. 사원 인덱스에서 읽은 ROWID로 사원 테이블을 찾아간다.  
3. 사원 테이블에서 읽은 사원번호 '3'번으로 고객관리 인덱스에서 탐색한다.
4. 고객관리 인덱스에서 찾은 사원번호 '3'으로 고객관리 테이블을 찾아간다.
5. 고객관리 테이블을 스캔하다가 '3' 보다 큰 번호가 나왔으므로 스캔을 중지한다.
6. 위 과정을 반복한다.
# NL 조인 수행과정 분석
```sql
select /*+ ordered use_nl(c) index(e) index(c) */
    e.사원번호, e.사원명, e.입사일자, c.고객번호, c.고객명, c.전화번호, c.최종주문금액
    from 사원 e, 고객 c
    where c.관리사원번호 = e.사원번호 // 1
    and e.입사일자 >= '19960101' // 2
    and e.부서코드 = 'Z123' // 3
    and c.최종주문금액 >= 20000 // 4 
```
### 인덱스 구성은 다음과 같다.
```plain
* 사원_PK : 사원번호
* 사원_X1 : 입사번호
* 고객_PK : 고객번호
* 고객_X1 : 관리사원번호
* 고객_X2 : 최종주문금액
```
두 테이블에 인덱스 힌트를 명시해씅므로 둘 다 인덱스를 이용해서 액세스한다.    
인덱스며은 명시하지 않았으므로 어떤 인덱스를 사용할지는 옵티마이저가 결정한다.  
SQL 조건절 우측에 표시한 번호로 비교순서를 나열하면 2->3->1->4 순이다.  

1. 조건절 번호 2: 입사일자 >= '19960101' 조건을 만족하는 사원을 찾으려고 사원_X1 인덱스를 Range Scan한다.
2. 조건절 번호 3: 사원 인덱스를 스캔하여 얻은 ROWID로 사원 테이블을 액세스해서 부서코드 = 'Z123'필터 조건을 만족하는지 확인한다.  
3. 조건절 번호 1: 사원 테이블에서 읽은 사원번호 값으로 조인 조건 (c.관리자사원번호 = e.사원번호)을 만족하는 고객 쪽 레코드를 찾으려고 고객_X1 인덱스를 Range 스캔한다.
4. 조건절 번호 4: 고객_X1 인덱스에서 읽은 ROWID로 고객 테이블을 액세스해서 최종주문금액 >= 20000 필터 조건을 만족하는지 확인한다.
> 각 단계를 모두 완료하고 다음 단계로 넘어가는것이 아니라 한 레코드씩 순처적으로 진행한다는 사실이다.  
![nl_실행과정](https://user-images.githubusercontent.com/23313008/166657768-652fcca4-934f-4fe8-a1cf-e73742857447.jpeg)  
위 그림을 번호순대로 차근차근 따라가보라.  
# NL 조인 튜닝포인트
### 사원_X1을 읽고 나서 사원 테이블을 액세스 하는 부분
만약 사원 테이블로 아주 많은 양의 랜덤 액세스가 발생했고 테이블에서 부서코드 = 'Z123'조건에 필터링 되는 비율이 높다면  
사원_X1 인덱스에 부서코드를 추가하는 방안을 고려해야 한다.  
### 고객_X1 인덱스를 탐색하는 부분
고객_X1 인덱스를 탐색하는 횟수, 즉 조인 액세스 횟수가 많을수록 성능이 느려진다.  
조인 액세스 횟수는 Outer 테이블인 사원을 읽고 필터링한 결과 건수에 의해 결정된다.  
위 (NL 조인 수행 탐색과정 분섣)에 SQL에서는 부서코드 = 'Z123' 조건을 만족하는 컬럼이 3건이 있고 3번의 조인 시도가 발생했다.  
만약 부서코드 조건을 만족하는 레코드가 10만건이고 고객_X1 인덱스 Depth가 3이라면 인덱스 수직적 탐색 과정에서만 30만개 블록을 읽어야하고  
수평 탐색 과정에서는 추가적인 블록 I/O가 더해진다.  
### 고객_X1 인덱스를 읽고 나서 고객 테이블을 액세스 하는 부분
최종주문금액 >= 20000 조건에 의해 필터링 되는 비율이 높다면 고객_X1 인덱스에 최종주문금액 컬럼을 추가하는 방안을 고려해야한다.  
> 마지막으로, 맨 처음 액세스하는 사원_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우된다는 사실도 기억하기 바란다.  
# NL 조인 특징
- 랜덤 액세스 위주 조인 방식
- 랜덤 액세스 방식이기 때문에 인덱스 구성이 잘되어있어도 대량 데이터 조인시 NL조인이 불리한 이유가 이것때문.
- 한 레코드씩 순처적으로 진행한다.
- 첫번째 특징 때문에 대량 데이터 조인시 한계를 드러내지만 이 두 번째 특징 덕에 아무리 큰 테이블을 조인하더라도 매우 빠른 응답속도를 낼 수 있음 (부분범위처리가 가능한 상황에서만)
- 인덱스 구성 전략이 중요함
> NL조인은 소량 데이터를 주로 처리하거나 부분범위 처리가 가능한 OLTP시스템에 적합한 조인 방식
# NL조인 확장 메카니즘
> 버전이 올라가면서 오라클 데이터베이스는 NL조인 성능을 높이기 위해 테이블 Prefetch와 배치 I/O기능을 도입했다.  
### 테이블 Prefetch
- 인덱스를 이용해 테이블을 액세스 하다가 디스크 I/O가 필요해지면 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능  
### 배치 I/O
- 디스크 I/O를 미뤘다가 읽는 블록이 일정량 쌓이면 한꺼번에 처리하는 기능
> 두 기능 다 읽는 블록마다 건건이 I/O Call을 발생시키는 비효율을 줄이기 위해 고안되었다.  
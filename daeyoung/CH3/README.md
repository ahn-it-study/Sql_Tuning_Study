# 인덱스 튜닝
### 파티션 프루닝?
> 하드 파싱이나 실행 시점에서 SQL 조건절을 분성하여 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외시키는 기능??  
> 샤딩??
# 인덱스 ROWID는 물리적 주소인가 논리적 주소인가?
## ROWID의 구성요소
- 데이터파일 번호
- 오브젝트 번호
- 블록 번호

## 인덱스를 스캔하는 이유
- 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 ROWID를 얻으려는데 있다.  
## 그래서?
-> 물리적으로 직접 연결되는것이 아닌 테이블 레코드를 찾아가기위한 논리적 주소 정보를 가지고 있기 때문이다.
-> 인덱스 ROWID는 논리적 주소이고 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는다. (물리적으로 직접 연결되어있는 구조가 아님.)
-> 그래서 ROWID는 물리적 주소보다 논리적 주소에 가깝다.

# 메인 메모리 DB와의 비교
## Main Memory Database? (REDIS? Memcached?)
- 데이터를 모두 메인메모리에 올려놓고 메인 메모리를 통해서만 I/O를 수행하는 DB  
잘 튜닝된 [OLTP](https://mozi.tistory.com/80) 데이터베이스 시스템이라면 버퍼캐시 히트율이 99% 이상이다.  
그런데도 메인 메모리 데이터베이스보다 빠르지 않다. 특히 대용량 데이터를 인덱스로 액세스 할 때에는 엄청난 차이가난다.   
## Main Memory Database가 더 빠를 수 밖에 없는 이유
- 어떤 메인 메모리 DB의 경우 인스턴스를 기동하면 디스크에 저장된 데이터를 버퍼캐시로 로딩하고 이어서 인덱스를 생성한다.   
- 디스크상의 주소정보를 가지는게 아니다. 실제 메인 메모리 상의 주소정보를 가진다.  
-> 인덱스를 경유해 액세스 하는 비용이 오라클과 비교도 할 수 없을정도로 낮음  
-> 일반 DBMS에서 인덱스 ROWID를 이용한 테이블 액세스가 생각만큼 빠르지 않은 이유임.  

## I/O 메커니즘 복기
### 버퍼 캐시
- DBA(Data Block Address)를 읽으려면 매번 디스크상에서 불러올 순 없다.  
- I/O성능을 높이려면 버퍼 캐시를 활용해야한다.  
- 그래서 블록을 읽을 땐 디스크로 가기전에 버퍼캐시를 먼저 찾아본다.  
- 읽고자 하는 DBA를 해시 함수에 넣어서 해시 체인을 찾고 거기에서 버퍼 헤더를 찾는다.  
- 반면 실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱이 되는데 그 주소값을 버퍼 헤더가 가지고 있다.  
### 버퍼 캐시 탐색과정
1. 해시 알고리즘으로 버퍼 헤더를 찾는다 (Input은 DBA)  
2. 거기서 얻은 주소값으로 버퍼 블록을 찾아간다.  
### 하지만
인덱스 리프 블록에 있는 ROWID를 취득했다하더라도 버퍼캐시 탐색은 무조건 일어나게된다.  
그런데 버퍼캐시는 공유자원이다. 그렇기 때문에 동시 액세스가 심할 땐 캐시버퍼 체인 래치와 버퍼 Lock에 대한 경합까지 발생한다.  
이처럼 인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조다.  
## 인덱스 ROWID는 우편주소
- DISK DB(일반 DBMS)가 사용하는 ROWID를 우편주소에 비유
- 메인 메모리 DB가 사용하는 포인터를 전화번호에 비유
> 전화통신은 물리적으로 연결된 통신망을 이용하므로 전화번호를 누르면 바로 상대방과 통화할 수 있다.  
> 우편통신은 봉투에 적힌대로 우체부 아저씨가 찾아다니는 구조이므로 전화와는 비교도 할 수 없이 느리다.  

-> 책에서 강조하는 것은 인덱스를 통해 테이블을 찾아가는게 얼마나 큰 작업인지 상기시켜주려는것 같음  
-> 인덱스가 무조건적으로 빠르다고 생각하면 안된다.  
# Clustering Factor
> 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도   
예를들어 거주지역 = 제주에 해당하는 고객이 물리적으로 근접해있다면 흩어져 있을 때 보다 데이터를 찾는 속도가 빠르다.  
또 한가지 더 들어보자면 분가한 10명의 자녀들이 한 동네에 살고있다면 부모 있장에서는 클러스터린 팩터가 좋은것이다.  
한 동네만 돌면 자녀들의 집을 다 방문할 수 있기 때문이다.  
![클러스터링 팩터가 좋은상태](https://user-images.githubusercontent.com/23313008/165489339-4b2ba317-f876-4b2d-98a5-220823bc35b7.png)  
(클러스터링 팩터가 좋은 경우.png)  
### Clustering Factor가 좋지 않은 경우
![notgood](https://user-images.githubusercontent.com/23313008/165489799-a5c3e6ea-71ca-4b26-9ffb-7b9fe25ebbc1.png)  
(클러스터링 팩터가 좋지 않은 경우.png)  
인덱스 레코드 정렬순서화 테이블 레코드 정렬 순서가 전혀 일치하지 않는다.  
  


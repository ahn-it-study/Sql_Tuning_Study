# 인덱스 튜닝
### 파티션 프루닝?
> 하드 파싱이나 실행 시점에서 SQL 조건절을 분성하여 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외시키는 기능??  
> 샤딩??
# 인덱스 ROWID는 물리적 주소인가 논리적 주소인가?
## ROWID의 구성요소
- 데이터파일 번호
- 오브젝트 번호
- 블록 번호

## 인덱스를 스캔하는 이유
- 검색 조건을 만족하는 소량의 데이터를 인덱스에서 빨리 찾고 거기서 테이블 레코드를 찾아가기 위한 ROWID를 얻으려는데 있다.  
## 그래서?
-> 물리적으로 직접 연결되는것이 아닌 테이블 레코드를 찾아가기위한 논리적 주소 정보를 가지고 있기 때문이다.
-> 인덱스 ROWID는 논리적 주소이고 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담는다. (물리적으로 직접 연결되어있는 구조가 아님.)
-> 그래서 ROWID는 물리적 주소보다 논리적 주소에 가깝다.

# 메인 메모리 DB와의 비교
## Main Memory Database? (REDIS? Memcached?)
- 데이터를 모두 메인메모리에 올려놓고 메인 메모리를 통해서만 I/O를 수행하는 DB  
잘 튜닝된 [OLTP](https://mozi.tistory.com/80) 데이터베이스 시스템이라면 버퍼캐시 히트율이 99% 이상이다.  
그런데도 메인 메모리 데이터베이스보다 빠르지 않다. 특히 대용량 데이터를 인덱스로 액세스 할 때에는 엄청난 차이가난다.   
## Main Memory Database가 더 빠를 수 밖에 없는 이유
- 어떤 메인 메모리 DB의 경우 인스턴스를 기동하면 디스크에 저장된 데이터를 버퍼캐시로 로딩하고 이어서 인덱스를 생성한다.   
- 디스크상의 주소정보를 가지는게 아니다. 실제 메인 메모리 상의 주소정보를 가진다.  
-> 인덱스를 경유해 액세스 하는 비용이 오라클과 비교도 할 수 없을정도로 낮음  
-> 일반 DBMS에서 인덱스 ROWID를 이용한 테이블 액세스가 생각만큼 빠르지 않은 이유임.  

## I/O 메커니즘 복기
### 버퍼 캐시
- DBA(Data Block Address)를 읽으려면 매번 디스크상에서 불러올 순 없다.  
- I/O성능을 높이려면 버퍼 캐시를 활용해야한다.  
- 그래서 블록을 읽을 땐 디스크로 가기전에 버퍼캐시를 먼저 찾아본다.  
- 읽고자 하는 DBA를 해시 함수에 넣어서 해시 체인을 찾고 거기에서 버퍼 헤더를 찾는다.  
- 반면 실제 데이터가 담긴 버퍼 블록은 매번 다른 위치에 캐싱이 되는데 그 주소값을 버퍼 헤더가 가지고 있다.  
### 버퍼 캐시 탐색과정
1. 해시 알고리즘으로 버퍼 헤더를 찾는다 (Input은 DBA)  
2. 거기서 얻은 주소값으로 버퍼 블록을 찾아간다.  
### 하지만
인덱스 리프 블록에 있는 ROWID를 취득했다하더라도 버퍼캐시 탐색은 무조건 일어나게된다.  
그런데 버퍼캐시는 공유자원이다. 그렇기 때문에 동시 액세스가 심할 땐 캐시버퍼 체인 래치와 버퍼 Lock에 대한 경합까지 발생한다.  
이처럼 인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조다.  
## 인덱스 ROWID는 우편주소
- DISK DB(일반 DBMS)가 사용하는 ROWID를 우편주소에 비유
- 메인 메모리 DB가 사용하는 포인터를 전화번호에 비유
> 전화통신은 물리적으로 연결된 통신망을 이용하므로 전화번호를 누르면 바로 상대방과 통화할 수 있다.  
> 우편통신은 봉투에 적힌대로 우체부 아저씨가 찾아다니는 구조이므로 전화와는 비교도 할 수 없이 느리다.  

-> 책에서 강조하는 것은 인덱스를 통해 테이블을 찾아가는게 얼마나 큰 작업인지 상기시켜주려는것 같음  
-> 인덱스가 무조건적으로 빠르다고 생각하면 안된다.  
# Clustering Factor
> 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도   
예를들어 거주지역 = 제주에 해당하는 고객이 물리적으로 근접해있다면 흩어져 있을 때 보다 데이터를 찾는 속도가 빠르다.  
또 한가지 더 들어보자면 분가한 10명의 자녀들이 한 동네에 살고있다면 부모 있장에서는 클러스터린 팩터가 좋은것이다.  
한 동네만 돌면 자녀들의 집을 다 방문할 수 있기 때문이다.  
![클러스터링 팩터가 좋은상태](https://user-images.githubusercontent.com/23313008/165489339-4b2ba317-f876-4b2d-98a5-220823bc35b7.png)  
(클러스터링 팩터가 좋은 경우.png)  
> 테이블 액세스량에 비해 블록 I/O가 적게 발생함
### Clustering Factor가 좋지 않은 경우
![notgood](https://user-images.githubusercontent.com/23313008/165489799-a5c3e6ea-71ca-4b26-9ffb-7b9fe25ebbc1.png)  
(클러스터링 팩터가 좋지 않은 경우.png)  
인덱스 레코드 정렬순서화 테이블 레코드 정렬 순서가 전혀 일치하지 않는다.  
## 인덱스 손익분기점
- 인덱스 ROWID를 이용하는것은 생각보다 고비용 구조이다.  
- 읽어야할 데이터가 일정량을 넘는 순간 테이블 전체를 스캔하는 것보다 오히려 느림  
- Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 흔히 인덱스 손익 분기점이라고 부른다.  
## 인덱스를 이용한 테이블 액세스가 Table Full Scan보다 느려지는 핵심요인
- Table Full Scan은 시퀀셜 액세스인 반면 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식
- Table Full Scan은 Multiblock I/O인 반면 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O  방식
> CF가 안좋으면 데이터 블록을 여러번 반복 액세스 하면서 물리적, 논리적 I/O 횟수가 늘어난다.  
## 인덱스 손익분기점 결정
- CF가 나쁠 경우 -> 5% 미만에서 결정
- 일반적으로 -> 5%-20%사이
- CF가 좋으면 -> 90% 수준까지 상승
여기서 말하는 %는 테이블 데이터 갯수기준이다.  
### 인덱스 손익분기점과 버퍼캐시 히트율
일반적으로 말하는 5%-20% 수준의 손익분기점은 10만건 이내, 많아봐야 100만건 이내 테이블에나 적용되는 수치이다.  
1000만건 수준의 큰 테이블에선 손익분기점이 더 낮아진다. 
왜냐하면 조회건수가 늘어날수록 버퍼캐시에서 찾을 '가능성'이 낮아지기 떄문이다.  
버퍼캐시에 할당하는 메모리 크기가 점점 늘어나고있는 추세이지만 요즘 기준으로 보통 수백만개 블록을 캐싱하는 수준이기 떄문이다.    
-> 만약 100만개의 데이터가 있는 테이블의 10%는 10만개이다. 이 정도 수준이면 버퍼캐시에서 데이터를 찾을 가능성은 꽤 높다.    
-> 만약 1000만개의 데이터가 있는 테이블이라면 100만개가 되는거고 즉 히트율을 점점 낮아질 수 밖에 없다.  
### 책에서 말하고 싶어하는 바
- 인덱스는 항상 좋은게 아니고 테이블 스캔이 항상 나쁜게 아니다.
## 온라인 프로그램 튜닝 vs 배치 프로그램 튜닝
### 온라인 프로그램
- 온라인 프로그램은 대개 소량의 데이터를 읽고 갱신하므로 인덱스를 효과적으로 활용하는 것이 무엇보다 중요하다.  
- 조인도 대부분 NL방식을 이용함  
- 인덱스를 이용해 소트 연산을 생략함으로써 2절에서 설명할 부분범위처리 방식으로 구현할 수 있다면, 온라인 환경에서 대량의 데이터를 조회할 때도 빠른 응답성을 보여줄 수 있음.  
### 배치 프로그램
- 배치 프로그램의 특성은 대량의 데이터를 조회하고 처리함  
- 그렇기 떄문에 전체를 빠르게 처리하는것을 목표로 삼아야함
- 대량의 데이터를 빠르게 처리하려면 인덱스와 NL 조인보다 Full Scan과 해시 조인이 유리하다.  
- 대량 배치 프로그램에선 인덱스보다 Full Scan이 효과적이지만 초대용량 테이블을 Full Scan하면 시스템에 부담이 상당하다.
- 따라서 대용량 배치 프로그램에서 중요한 튜닝 포인트는 파티션 활용 전략이 매우 중요한 튜닝요소이고 병렬처리까지 더할 수 있으면 금상천화이다.
### 대용량 배치 프로그램을 파티션을 활용하여 튜닝
고객이력변경 테이블  
- 고객번호, 고객명, 전화번호, 주소, 상태코드, 변경일시  
- **변경일시 조건으로 검색**
위 테이블에서 변경일시 기준으로 파티셔닝하면 변경일시 조건에만 해당하는 파티션을 골라서 Full Scan할 수 있다.   
- 보름 또는 일주일치 데이터만 조회하더라도 Full Scan이 유리함.  
- 심지어 2~3일 데이터를 조회할 때도 Full Scan이 유리할 수 있다.  
### 결국 테이블을 파티셔닝 하는 이유는
- Full Scan을 빠르게 처리하기 위해서다.  
> 다시 강조한다. 모든 성능 문제를 인덱스로 해결하려 해선 안된다. 인덱스는 다양한 튜닝 도구중 하나일 뿐이며 큰 테이블에서 아주 작인 일부 데이터를 빨리 찾고자 할 때 주로 사용한다.  
